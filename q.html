<style>
    body {
        padding: 3em;
    }
    pre {
        display: none;
        background: aqua;
        color: maroon;
        font-size: 1.2em;
        font-weight: bold;
        padding: 0.3em;
    }
    span.desc {
        color: olive;
    }
    span.example {
        font-weight: bold;
        color: blue;
    }
</style>
<script>
    function show(e) {
        var node = e.target;
        node.style.display = 'none';
        node.nextElementSibling.style.display = 'block';
    }
</script>
<h1>HJ1 字符串最后一个单词的长度</h1>
<p><span class="desc">描述</span><br/>计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾）<br/>输入描述：<br/>输入一行，代表要计算的字符串，非空，长度小于5000。<br/>输出描述：<br/>输出一个整数，表示输入字符串最后一个单词的长度。<br/><span class="example">示例1</span><br/>输入：<br/>hello nowcoder<br/>输出：<br/>8<br/>说明：<br/>最后一个单词为nowcoder，长度为8</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys

print(len(sys.stdin.read().split()[-1]))
</pre>
<hr/>
<h1>HJ2 计算某字符出现次数</h1>
<p><span class="desc">描述</span><br/>写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母）<br/><br/>数据范围：<br/>1≤n≤1000 <br/>输入描述：<br/>第一行输入一个由字母和数字以及空格组成的字符串，第二行输入一个字符。<br/>输出描述：<br/>输出输入字符串中含有该字符的个数。（不区分大小写字母）<br/><span class="example">示例1</span><br/>输入：<br/>ABCabc<br/>A<br/>输出：<br/>2</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


content, c, *_ = sys.stdin.read().split("\n")
print(content.lower().count(c.lower()))
</pre>
<hr/>
<h1>HJ3 明明的随机数</h1>
<p><span class="desc">描述</span><br/>明明生成了<br/>N个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。<br/>数据范围：<br/>1≤n≤1000  ，输入的数字大小满足<br/>1≤val≤500 <br/>输入描述：<br/>第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 具体格式可以参考下面的"示例"。<br/>输出描述：<br/>输出多行，表示输入数据处理后的结果<br/><span class="example">示例1</span><br/>输入：<br/>3<br/>2<br/>2<br/>1<br/>输出：<br/>1<br/>2<br/>说明：<br/>输入解释：<br/>第一个数字是3，也即这个小样例的N=3，说明用计算机生成了3个1到500之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：<br/>2<br/>2<br/>1<br/>所以样例的输出为：<br/>1<br/>2</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


arr = map(int, sys.stdin.read().strip().split("\n")[1:])
for number in sorted(set(arr)):
    print(number)
</pre>
<hr/>
<h1>HJ4 字符串分隔</h1>
<p><span class="desc">描述</span><br/>•输入一个字符串，请按长度为8拆分每个输入字符串并进行输出；<br/>•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。<br/>输入描述：<br/>连续输入字符串(每个字符串长度小于等于100)<br/>输出描述：<br/>依次输出所有分割后的长度为8的新字符串<br/><span class="example">示例1</span><br/>输入：<br/>abc<br/>输出：<br/>abc00000</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


s = sys.stdin.read().strip()
for i in range(0, len(s), 8):
    if i+8 > len(s):
        print(s[i:]+'0'*(i+8-len(s)))
    else:
        print(s[i:i+8])
</pre>
<hr/>
<h1>HJ5 进制转换</h1>
<p><span class="desc">描述</span><br/>写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。<br/><br/>数据范围：保证结果在<br/>1 \le n \le 2^{31}-1 \<br/>1≤n≤2<br/>31<br/>−1 <br/>输入描述：<br/>输入一个十六进制的数值字符串。<br/>输出描述：<br/>输出该数值的十进制字符串。不同组的测试用例用\n隔开。<br/><span class="example">示例1</span><br/>输入：<br/>0xAA<br/>输出：<br/>170</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


for hex in sys.stdin.read().strip().split("\n"):
    print(int(hex[2:], 16))
</pre>
<hr/>
<h1>HJ6 质数因子</h1>
<p><span class="desc">描述</span><br/>功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ）<br/><br/>数据范围：<br/>1 \le n \le 2 \times 10^{9} + 14 \<br/>1≤n≤2×10<br/>9<br/>+14 <br/>输入描述：<br/>输入一个整数<br/>输出描述：<br/>按照从小到大的顺序输出它的所有质数的因子，以空格隔开。<br/><span class="example">示例1</span><br/>输入：<br/>180<br/>输出：<br/>2 2 3 3 5</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys
import math


n = int(sys.stdin.read().strip())

i = 2
while i * i <= n:
    while n % i == 0:
        print(i, end=" ")
        n //= i
    i += 1
if n > 1:
    print(n)
</pre>
<hr/>
<h1>HJ7 取近似值</h1>
<p><span class="desc">描述</span><br/>写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于 0.5 ,向上取整；小于 0.5 ，则向下取整。<br/><br/>数据范围：保证输入的数字在 32 位浮点数范围内<br/>输入描述：<br/>输入一个正浮点数值<br/>输出描述：<br/>输出该数值的近似整数值<br/><span class="example">示例1</span><br/>输入：<br/>5.5<br/>输出：<br/>6<br/>说明：<br/>0.5>=0.5，所以5.5需要向上取整为6   <br/><span class="example">示例2</span><br/>输入：<br/>2.499<br/>输出：<br/>2<br/>说明：<br/>0.499<0.5，2.499向下取整为2</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


s = sys.stdin.read()
i, d = s.split(".")
n = int(i)
if d and d[0] > '4':
    n += 1
print(n)
</pre>
<hr/>
<h1>HJ8 合并表记录</h1>
<p><span class="desc">描述</span><br/>数据表记录包含表索引index和数值value（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照index值升序进行输出。<br/><br/><br/>提示:<br/>0 <= index <= 11111111<br/>1 <= value <= 100000<br/><br/>输入描述：<br/>先输入键值对的个数n（1 <= n <= 500）<br/>接下来n行每行输入成对的index和value值，以空格隔开<br/>输出描述：<br/>输出合并后的键值对（多行）<br/><span class="example">示例1</span><br/>输入：<br/>4<br/>0 1<br/>0 2<br/>1 2<br/>3 4<br/>输出：<br/>0 3<br/>1 2<br/>3 4<br/><span class="example">示例2</span><br/>输入：<br/>3<br/>0 1<br/>0 2<br/>8 9<br/>输出：<br/>0 3<br/>8 9</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


n, *data = sys.stdin.read().strip().split("\n")
rst = dict()
for line in data:
    k, v = tuple(map(int, line.split()))
    rst[k] = rst.get(k, 0) + v
for k in sorted(rst.keys()):
    print("{} {}".format(k, rst[k]))
</pre>
<hr/>
<h1>HJ9 提取不重复的整数</h1>
<p><span class="desc">描述</span><br/>输入一个 int 型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。<br/>保证输入的整数最后一位不是 0 。<br/><br/>数据范围：<br/>1 \le n \le 10^{8} \<br/>1≤n≤10<br/>8<br/> <br/>输入描述：<br/>输入一个int型整数<br/>输出描述：<br/>按照从右向左的阅读顺序，返回一个不含重复数字的新的整数<br/><span class="example">示例1</span><br/>输入：<br/>9876673<br/>输出：<br/>37689</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


l = list(sys.stdin.read().strip())[::-1]
s = ""
for c in l:
    if c not in s:
        s += c
print(s)
</pre>
<hr/>
<h1>HJ10 字符个数统计</h1>
<p><span class="desc">描述</span><br/>编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次<br/>例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。<br/><br/>数据范围：<br/>1≤n≤500 <br/>输入描述：<br/>输入一行没有空格的字符串。<br/>输出描述：<br/>输出 输入字符串 中范围在(0~127，包括0和127)字符的种数。<br/><span class="example">示例1</span><br/>输入：<br/>abc<br/>输出：<br/>3<br/><span class="example">示例2</span><br/>输入：<br/>aaa<br/>输出：<br/>1</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


print(len(set(sys.stdin.read().strip())))
</pre>
<hr/>
<h1>HJ11 数字颠倒</h1>
<p><span class="desc">描述</span><br/>输入一个整数，将这个整数以字符串的形式逆序输出<br/>程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001<br/><br/>数据范围：<br/>0 \le n \le 2^{30}-1 \<br/>0≤n≤2<br/>30<br/>−1 <br/>输入描述：<br/>输入一个int整数<br/>输出描述：<br/>将这个整数以字符串的形式逆序输出<br/><span class="example">示例1</span><br/>输入：<br/>1516000<br/>输出：<br/>0006151<br/><span class="example">示例2</span><br/>输入：<br/>0<br/>输出：<br/>0</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


print(sys.stdin.read().strip()[::-1])
</pre>
<hr/>
<h1>HJ12 字符串反转</h1>
<p><span class="desc">描述</span><br/>接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）<br/>输入描述：<br/>输入一行，为一个只包含小写字母的字符串。<br/>输出描述：<br/>输出该字符串反转后的字符串。<br/><span class="example">示例1</span><br/>输入：<br/>abcd<br/>输出：<br/>dcba</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


print(sys.stdin.read().strip()[::-1])
</pre>
<hr/>
<h1>HJ13 句子逆序</h1>
<p><span class="desc">描述</span><br/>将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”<br/>所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符<br/><br/>数据范围：输入的字符串长度满足<br/>1≤n≤1000 <br/><br/>注意本题有多组输入<br/>输入描述：<br/>输入一个英文语句，每个单词用空格隔开。保证输入只包含空格和字母。<br/>输出描述：<br/>得到逆序的句子<br/><span class="example">示例1</span><br/>输入：<br/>I am a boy<br/>输出：<br/>boy a am I<br/><span class="example">示例2</span><br/>输入：<br/>nowcoder<br/>输出：<br/>nowcoder</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


print(" ".join(sys.stdin.read().strip().split()[::-1]))
</pre>
<hr/>
<h1>HJ14 字符串排序</h1>
<p><span class="desc">描述</span><br/>给定 n 个字符串，请对 n 个字符串按照字典序排列。<br/><br/>数据范围：<br/>1≤n≤1000  ，字符串长度满足<br/>1≤len≤100 <br/>输入描述：<br/>输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。<br/>输出描述：<br/>数据输出n行，输出结果为按照字典序排列的字符串。<br/><span class="example">示例1</span><br/>输入：<br/>9<br/>cap<br/>to<br/>cat<br/>card<br/>two<br/>too<br/>up<br/>boat<br/>boot<br/>输出：<br/>boat<br/>boot<br/>cap<br/>card<br/>cat<br/>to<br/>too<br/>two<br/>up</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


n, *data = sys.stdin.read().strip().split("\n")
data.sort()
print("\n".join(data))
</pre>
<hr/>
<h1>HJ15 求int型正整数在内存中存储时1的个数</h1>
<p><span class="desc">描述</span><br/>输入一个 int 型的正整数，计算出该 int 型数据在内存中存储时 1 的个数。<br/><br/>数据范围：保证在 32 位整型数字范围内<br/>输入描述：<br/> 输入一个整数（int类型）<br/>输出描述：<br/> 这个数转换成2进制后，输出1的个数<br/><span class="example">示例1</span><br/>输入：<br/>5<br/>输出：<br/>2<br/><span class="example">示例2</span><br/>输入：<br/>0<br/>输出：<br/>0</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


print(bin(int(sys.stdin.read().strip())).count('1'))
</pre>
<hr/>
<h1>HJ16 购物单</h1>
<p><span class="desc">描述</span><br/>王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：<br/>主件 附件<br/>电脑 打印机，扫描仪<br/>书柜 图书<br/>书桌 台灯，文具<br/>工作椅 无<br/>如果要买归类为附件的物品，必须先买该附件所属的主件，且每件物品只能购买一次。<br/>每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。<br/>王强查到了每件物品的价格（都是 10 元的整数倍），而他只有 N 元的预算。除此之外，他给每件物品规定了一个重要度，用整数 1 ~ 5 表示。他希望在花费不超过 N 元的前提下，使自己的满意度达到最大。<br/>满意度是指所购买的每件物品的价格与重要度的乘积的总和，假设设第<br/>i件物品的价格为<br/>v[i]<br/>v[i]，重要度为<br/>w[i]<br/>w[i]，共选中了<br/>k件物品，编号依次为<br/>j<br/>1<br/>,j<br/>2<br/>,...,j<br/>k<br/>，则满意度为：<br/>v[j_1]*w[j_1]+v[j_2]*w[j_2]+ … +v[j_k]*w[j_k]<br/>v[j<br/>1<br/>]∗w[j<br/>1<br/>]+v[j<br/>2<br/>]∗w[j<br/>2<br/>]+…+v[j<br/>k<br/>]∗w[j<br/>k<br/>]。（其中 * 为乘号）<br/>请你帮助王强计算可获得的最大的满意度。<br/><br/><br/>输入描述：<br/>输入的第 1 行，为两个正整数N，m，用一个空格隔开：<br/>（其中 N （ N<32000 ）表示总钱数， m （m <60 ）为可购买的物品的个数。）<br/><br/>从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q<br/><br/>（其中 v 表示该物品的价格（ v<10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号）<br/> <br/>输出描述：<br/> 输出一个正整数，为张强可以获得的最大的满意度。<br/><span class="example">示例1</span><br/>输入：<br/>1000 5<br/>800 2 0<br/>400 5 1<br/>300 5 1<br/>400 3 0<br/>500 2 0<br/>输出：<br/>2200<br/><span class="example">示例2</span><br/>输入：<br/>50 5<br/>20 3 5<br/>20 3 5<br/>10 3 0<br/>10 2 0<br/>10 1 0<br/>输出：<br/>130<br/>说明：<br/>由第1行可知总钱数N为50以及希望购买的物品个数m为5；<br/>第2和第3行的q为5，说明它们都是编号为5的物品的附件；<br/>第4~6行的q都为0，说明它们都是主件，它们的编号依次为3~5；<br/>所以物品的价格与重要度乘积的总和的最大值为10*1+20*3+20*3=130</p>
<button onclick='show(event)'>显示代码</button>
<pre>
total, cnt = list(map(int, input().split()))

goods = {}
for i in range(cnt):
    price, weight, master = list(map(int, input().split()))
    if master == 0:
        goods[i] = [[price, price * weight]] + goods.get(i, [])
    else:
        goods[master-1] = goods.get(master-1, []) + [[price, price * weight]]

possible = []
for master in goods:
    candidate = [goods[master][0]]
    for g in goods[master][1:]:
        candidate += [[c[0]+g[0], c[1]+g[1]] for c in candidate]
    possible.append(candidate)

dp = [[0] * (total+1) for _ in range(len(possible)+1)]
category = len(goods)
for i in range(1, category+1):
    for j in range(10, total+1, 10):
        v = dp[i-1][j]
        for c in possible[i-1]:
            if j >= c[0]:
                v = max(v, dp[i-1][j-c[0]]+c[1])
        dp[i][j] = v

print(dp[-1][-1])
</pre>
<hr/>
<h1>HJ17 坐标移动</h1>
<p><span class="desc">描述</span><br/>开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。<br/>输入：<br/>合法坐标为A(或者D或者W或者S) + 数字（两位以内）<br/>坐标之间以;分隔。<br/>非法坐标点需要进行丢弃。如AA10;  A1A;  $%$;  YAD; 等。<br/>下面是一个简单的例子 如：<br/>A10;S20;W10;D30;X;A1A;B10A11;;A10;<br/>处理过程：<br/>起点（0,0）<br/>+   A10   =  （-10,0）<br/>+   S20   =  (-10,-20)<br/>+   W10  =  (-10,-10)<br/>+   D30  =  (20,-10)<br/>+   x    =  无效<br/>+   A1A   =  无效<br/>+   B10A11   =  无效<br/>+  一个空 不影响<br/>+   A10  =  (10,-10)<br/>结果 （10， -10）<br/><br/>数据范围：每组输入的字符串长度满足<br/>1≤n≤10000  ，坐标保证满足<br/>-2^{31} \le x,y \le 2^{31}-1 \<br/>−2<br/>31<br/>≤x,y≤2<br/>31<br/>−1  ，且数字部分仅含正数<br/>输入描述：<br/>一行字符串<br/>输出描述：<br/>最终坐标，以逗号分隔<br/><span class="example">示例1</span><br/>输入：<br/>A10;S20;W10;D30;X;A1A;B10A11;;A10;<br/>输出：<br/>10,-10<br/><span class="example">示例2</span><br/>输入：<br/>ABC;AKL;DA1;<br/>输出：<br/>0,0</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys
import re


pattern = re.compile('^[ADWS]\d+$')

cmds = sys.stdin.read().strip().split(";")
pos = (0, 0)
for cmd in cmds:
    if pattern.match(cmd):
        if cmd[0] == 'A':
            pos = (pos[0] - int(cmd[1:]), pos[1])
        elif cmd[0] == 'W':
            pos = (pos[0], pos[1] + int(cmd[1:]))
        elif cmd[0] == 'D':
            pos = (pos[0] + int(cmd[1:]), pos[1])
        else:
            pos = (pos[0], pos[1] - int(cmd[1:]))
print("{},{}".format(*pos))
</pre>
<hr/>
<h1>HJ18 识别有效的IP地址和掩码并进行分类统计</h1>
<p><span class="desc">描述</span><br/>请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。<br/>所有的IP地址划分为 A,B,C,D,E五类<br/>A类地址从1.0.0.0到126.255.255.255;<br/>B类地址从128.0.0.0到191.255.255.255;<br/>C类地址从192.0.0.0到223.255.255.255;<br/>D类地址从224.0.0.0到239.255.255.255；<br/>E类地址从240.0.0.0到255.255.255.255<br/><br/>私网IP范围是：<br/>从10.0.0.0到10.255.255.255<br/>从172.16.0.0到172.31.255.255<br/>从192.168.0.0到192.168.255.255<br/><br/>子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码）<br/>（注意二进制下全是1或者全是0均为非法子网掩码）<br/><br/>注意：<br/>1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时请忽略<br/>2. 私有IP地址和A,B,C,D,E类地址是不冲突的<br/><br/>输入描述：<br/>多行字符串。每行一个IP地址和掩码，用~隔开。<br/>请参考帖子https://www.nowcoder.com/discuss/276处理循环输入的问题。<br/>输出描述：<br/>统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。<br/><span class="example">示例1</span><br/>输入：<br/>10.70.44.68~255.254.255.0<br/>1.0.0.1~255.0.0.0<br/>192.168.0.2~255.255.255.0<br/>19..0.~255.255.255.0<br/>输出：<br/>1 0 1 0 0 2 1<br/>说明：<br/>10.70.44.68~255.254.255.0的子网掩码非法，19..0.~255.255.255.0的IP地址非法，所以错误IP地址或错误掩码的计数为2；<br/>1.0.0.1~255.0.0.0是无误的A类地址；<br/>192.168.0.2~255.255.255.0是无误的C类地址且是私有IP；<br/>所以最终的结果为1 0 1 0 0 2 1      <br/><span class="example">示例2</span><br/>输入：<br/>0.201.56.50~255.255.111.255<br/>127.201.56.50~255.255.111.255<br/>输出：<br/>0 0 0 0 0 0 0<br/>说明：<br/>类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时请忽略</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


def to_number(ip):
    try:
        nums = list(map(int, ip.split(".")[::-1]))
        weight = 1
        rst = 0
        for n in nums:
            if not 0 <= n < 256:
                return -1
            rst += n * weight
            weight *= 256
        return rst
    except Exception as _:
        return -1


def check_mask(v):
    s = bin(v)[2:]
    return len(s) == 32 and s.lstrip("1").rstrip("0") == ""


category = [
    ("1.0.0.0",   "126.255.255.255", "A"),
    ("128.0.0.0", "191.255.255.255", "B"),
    ("192.0.0.0", "223.255.255.255", "C"),
    ("224.0.0.0", "239.255.255.255", "D"),
    ("240.0.0.0", "255.255.255.255", "E"),
]


private = [
    ("10.0.0.0", "10.255.255.255"),
    ("172.16.0.0", "172.31.255.255"),
    ("192.168.0.0", "192.168.255.255"),
]


cmap = [(to_number(e[0]), to_number(e[1]), e[2]) for e in category]
priv = [(to_number(e[0]), to_number(e[1])) for e in private]

cinfo = { c: 0 for c in "ABCDE" }
Errc, Pc = 0, 0

for line in sys.stdin.read().strip().split("\n"):
    si, sm = line.split("~")

    if "0." == si[:2] or "127." == si[:4]:
        continue

    ip, mask = list(map(to_number, [si, sm]))
    if sm in '255.255.255.255' or ip < 0 or mask <= 0 or not check_mask(mask):
        Errc += 1
        continue

    for p in priv:
        if p[0] <= ip <= p[1]:
            Pc += 1

    for p in cmap:
        if p[0] <= ip <= p[1]:
            cinfo[p[2]] += 1
            break

print(" ".join([str(cinfo[c]) for c in "ABCDE"] + [str(Errc), str(Pc)]))
</pre>
<hr/>
<h1>HJ19 简单错误记录</h1>
<p><span class="desc">描述</span><br/>开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。<br/><br/>处理：<br/><br/>1、 记录最多8条错误记录，循环记录，最后只用输出最后出现的八条错误记录。对相同的错误记录只记录一条，但是错误计数增加。最后一个斜杠后面的带后缀名的部分（保留最后16位）和行号完全匹配的记录才做算是“相同”的错误记录。<br/>2、 超过16个字符的文件名称，只记录文件的最后有效16个字符；<br/>3、 输入的文件可能带路径，记录文件名称不能带路径。也就是说，哪怕不同路径下的文件，如果它们的名字的后16个字符相同，也被视为相同的错误记录<br/>4、循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准<br/><br/>数据范围：错误记录数量满足<br/>1≤n≤100  ，每条记录长度满足<br/>1≤len≤100 <br/>输入描述：<br/>每组只包含一个测试用例。一个测试用例包含一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。<br/>输出描述：<br/>将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开，如：<br/><span class="example">示例1</span><br/>输入：<br/>D:\zwtymj\xccb\ljj\cqzlyaszjvlsjmkwoqijggmybr 645<br/>E:\je\rzuwnjvnuz 633<br/>C:\km\tgjwpb\gy\atl 637<br/>F:\weioj\hadd\connsh\rwyfvzsopsuiqjnr 647<br/>E:\ns\mfwj\wqkoki\eez 648<br/>D:\cfmwafhhgeyawnool 649<br/>E:\czt\opwip\osnll\c 637<br/>G:\nt\f 633<br/>F:\fop\ywzqaop 631<br/>F:\yay\jc\ywzqaop 631<br/>D:\zwtymj\xccb\ljj\cqzlyaszjvlsjmkwoqijggmybr 645<br/>输出：<br/>rzuwnjvnuz 633 1<br/>atl 637 1<br/>rwyfvzsopsuiqjnr 647 1<br/>eez 648 1<br/>fmwafhhgeyawnool 649 1<br/>c 637 1<br/>f 633 1<br/>ywzqaop 631 2<br/>说明：<br/>由于D:\cfmwafhhgeyawnool 649的文件名长度超过了16个字符，达到了17，所以第一个字符'c'应该被忽略。<br/>记录F:\fop\ywzqaop 631和F:\yay\jc\ywzqaop 631由于文件名和行号相同，因此被视为同一个错误记录，哪怕它们的路径是不同的。<br/>由于循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准，所以D:\zwtymj\xccb\ljj\cqzlyaszjvlsjmkwoqijggmybr 645不会被记录。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


data = sys.stdin.read().strip().split("\n")
calc = []
for l in data:
    f, n = l.split()
    fn = f.split("\\")[-1]
    ek = fn[-16:] + " " + n
    for p in calc:
        if p[0] == ek:
            p[1] += 1
            break
    else:
        calc.append([ek, 1])
for p in calc[-8:]:
    print("{} {}".format(*p))
</pre>
<hr/>
<h1>HJ20 密码验证合格程序</h1>
<p><span class="desc">描述</span><br/>密码要求:<br/>1.长度超过8位<br/>2.包括大小写字母.数字.其它符号,以上四种至少三种<br/>3.不能有长度大于2的包含公共元素的子串重复 （注：其他符号不含空格或换行）<br/><br/>数据范围：输入的字符串长度满足<br/>1≤n≤100 <br/>输入描述：<br/>一组字符串。<br/>输出描述：<br/>如果符合要求输出：OK，否则输出NG<br/><span class="example">示例1</span><br/>输入：<br/>021Abc9000<br/>021Abc9Abc1<br/>021ABC9000<br/>021$bc9000<br/>输出：<br/>OK<br/>NG<br/>NG<br/>OK</p>
<button onclick='show(event)'>显示代码</button>
<pre>
while True:
    try:
        s = input()
        if len(s) <= 8:
            print("NG")
            continue
        cs = set()
        
        for c in s:
            if 'a' <= c <= 'z':
                cs.add('a')
            elif 'A' <= c <= 'Z':
                cs.add('A')
            elif '0' <= c <= '9':
                cs.add('0')
            else:
                cs.add('*')
        if len(cs) < 3:
            print("NG")
            continue
            
        for i in range(len(s)-2):
            if s.count(s[i:i+3]) > 1:
                print("NG")
                break
        else:
            print("OK")
    except:
        break
</pre>
<hr/>
<h1>HJ21 简单密码</h1>
<p><span class="desc">描述</span><br/>现在有一种密码变换算法。<br/>九键手机键盘上的数字与字母的对应： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0，把密码中出现的小写字母都变成九键键盘对应的数字，如：a 变成 2，x 变成 9.<br/>而密码中出现的大写字母则变成小写之后往后移一位，如：X ，先变成小写，再往后移一位，变成了 y ，例外：Z 往后移是 a 。<br/>数字和其它的符号都不做变换。<br/>数据范围： 输入的字符串长度满足<br/>1≤n≤100 <br/>输入描述：<br/>输入一组密码，长度不超过100个字符。<br/>输出描述：<br/>输出密码变换后的字符串<br/><span class="example">示例1</span><br/>输入：<br/>YUANzhi1987<br/>输出：<br/>zvbo9441987</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


cp = "abc--2,def--3,ghi--4,jkl--5,mno--6,pqrs--7,tuv--8,wxyz--9".split(",")
cl = []
tp = dict()
for p in cp:
    ks, v = p.split("--")
    for k in ks:
        cl.append(k.upper())
        tp[k] = v
ncl = cl[1:]
ncl.append(cl[0])
ncl = map(lambda c:c.lower(), ncl)
tp.update(dict(zip(cl, ncl)))

nc = []
for c in sys.stdin.read().strip():
    nc.append(tp.get(c, c))
print("".join(nc))
</pre>
<hr/>
<h1>HJ22 汽水瓶</h1>
<p><span class="desc">描述</span><br/>某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。<br/>小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。<br/>数据范围：输入的正整数满足<br/>1≤n≤100 <br/><br/>注意：本题存在多组输入。输入的 0 表示输入结束，并不用输出结果。<br/>输入描述：<br/>输入文件最多包含 10 组测试数据，每个数据占一行，仅包含一个正整数 n（ 1<=n<=100 ），表示小张手上的空汽水瓶数。n=0 表示输入结束，你的程序不应当处理这一行。<br/>输出描述：<br/>对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。<br/><span class="example">示例1</span><br/>输入：<br/>3<br/>10<br/>81<br/>0<br/>输出：<br/>1<br/>5<br/>40<br/>说明：<br/>样例 1 解释：用三个空瓶换一瓶汽水，剩一个空瓶无法继续交换<br/>样例 2 解释：用九个空瓶换三瓶汽水，剩四个空瓶再用三个空瓶换一瓶汽水，剩两个空瓶，向老板借一个空瓶再用三个空瓶换一瓶汽水喝完得一个空瓶还给老板</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


data = sys.stdin.read().strip().split("\n")
for line in data:
    n = int(line)
    if n == 0:
        break
    
    b = 0
    while n >= 3:
        t = n // 3
        b += t
        n %= 3
        n += t
    print(b if n < 2 else b + 1)
</pre>
<hr/>
<h1>HJ23 删除字符串中出现次数最少的字符</h1>
<p><span class="desc">描述</span><br/>实现删除字符串中出现次数最少的字符，若出现次数最少的字符有多个，则把出现次数最少的字符都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。<br/><br/>数据范围：输入的字符串长度满足<br/>1≤n≤20  ，保证输入的字符串中仅出现小写字母<br/>输入描述：<br/>字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。<br/>输出描述：<br/>删除字符串中出现次数最少的字符后的字符串。<br/><span class="example">示例1</span><br/>输入：<br/>aabcddd<br/>输出：<br/>aaddd</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


ct = dict()
s = sys.stdin.read().strip()
for c in s:
    ct[c] = ct.get(c, 0) + 1
cnts = [(ct[k], k) for k in ct]
cnts.sort()
mc = cnts[0][0]
for p in cnts:
    if p[0] > mc:
        break
    if p[0] == mc:
        s = s.replace(p[1], '')
print(s)
</pre>
<hr/>
<h1>HJ24 合唱队</h1>
<p><span class="desc">描述</span><br/>N 位同学站成一排，音乐老师要请最少的同学出列，使得剩下的 K 位同学排成合唱队形。<br/>设<br/>K位同学从左到右依次编号为 1，2…，K ，他们的身高分别为<br/>T<br/>1<br/>,T<br/>2<br/>,…,T<br/>K<br/>，若存在<br/>i(1\leq i\leq K)<br/>i(1≤i≤K) 使得<br/>T<br/>1<br/><T<br/>2<br/><......<T<br/>i−1<br/><T<br/>i<br/>且<br/>T<br/>i<br/>>T<br/>i+1<br/>>......>T<br/>K<br/>，则称这<br/>K名同学排成了合唱队形。<br/>通俗来说，能找到一个同学，他的两边的同学身高都依次严格降低的队形就是合唱队形。<br/>例子：<br/>123 124 125 123 121 是一个合唱队形<br/>123 123 124 122不是合唱队形，因为前两名同学身高相等，不符合要求<br/>123 122 121 122不是合唱队形，因为找不到一个同学，他的两侧同学身高递减。<br/><br/>你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。<br/><br/>注意：不允许改变队列元素的先后顺序 且 不要求最高同学左右人数必须相等<br/><br/>数据范围：<br/>1≤n≤3000 <br/><br/>输入描述：<br/>用例两行数据，第一行是同学的总数 N ，第二行是 N 位同学的身高，以空格隔开<br/>输出描述：<br/>最少需要几位同学出列<br/><span class="example">示例1</span><br/>输入：<br/>8<br/>186 186 150 200 160 130 197 200<br/>输出：<br/>4<br/>说明：<br/>由于不允许改变队列元素的先后顺序，所以最终剩下的队列应该为186 200 160 130或150 200 160 130</p>
<button onclick='show(event)'>显示代码</button>
<pre>
_ = input()
arr = list(map(int, input().split()))


def f(nums, n):
    dp = [1] * n
    for i in range(n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j]+1)
    return dp


def g(nums, n):
    dp = [1] * n
    for i in reversed(range(n)):
        for j in range(i+1, n):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j]+1)
    return dp


n = len(arr)
print(n - max(sum(p) for p in zip(f(arr, n), g(arr, n))) + 1)
</pre>
<hr/>
<h1>HJ25 数据分类处理</h1>
<p><span class="desc">描述</span><br/>信息社会，有海量的数据需要分析处理，比如公安局分析身份证号码、 QQ 用户、手机号码、银行帐号等信息及活动记录。<br/>采集输入大数据和分类规则，通过大数据分类处理程序，将大数据分类输出。<br/><br/>数据范围：<br/>1≤I,R≤100  ，输入的整数大小满足<br/>0 \le val \le 2^{31}-1\<br/>0≤val≤2<br/>31<br/>−1 <br/>输入描述：<br/>一组输入整数序列I和一组规则整数序列R，I和R序列的第一个整数为序列的个数（个数不包含第一个整数）；整数范围为0~(2^31)-1，序列个数不限<br/>输出描述：<br/>从R依次中取出Ri，对I进行处理，找到满足条件的I： <br/>I整数对应的数字需要连续包含Ri对应的数字。比如Ri为23，I为231，那么I包含了Ri，条件满足 。 <br/>按Ri从小到大的顺序:<br/>(1)先输出Ri； <br/>(2)再输出满足条件的I的个数； <br/>(3)然后输出满足条件的I在I序列中的位置索引(从0开始)； <br/>(4)最后再输出I。 <br/>附加条件： <br/>(1)Ri需要从小到大排序。相同的Ri只需要输出索引小的以及满足条件的I，索引大的需要过滤掉 <br/>(2)如果没有满足条件的I，对应的Ri不用输出 <br/>(3)最后需要在输出序列的第一个整数位置记录后续整数序列的个数(不包含“个数”本身)<br/> 序列I：15,123,456,786,453,46,7,5,3,665,453456,745,456,786,453,123（第一个15表明后续有15个整数） <br/>序列R：5,6,3,6,3,0（第一个5表明后续有5个整数） <br/>输出：30, 3,6,0,123,3,453,7,3,9,453456,13,453,14,123,6,7,1,456,2,786,4,46,8,665,9,453456,11,456,12,786<br/>说明：<br/>30----后续有30个整数<br/>3----从小到大排序，第一个Ri为0，但没有满足条件的I，不输出0，而下一个Ri是3<br/>6--- 存在6个包含3的I <br/>0--- 123所在的原序号为0 <br/>123--- 123包含3，满足条件 <br/><span class="example">示例1</span><br/>输入：<br/>15 123 456 786 453 46 7 5 3 665 453456 745 456 786 453 123<br/>5 6 3 6 3 0<br/>输出：<br/>30 3 6 0 123 3 453 7 3 9 453456 13 453 14 123 6 7 1 456 2 786 4 46 8 665 9 453456 11 456 12 786<br/>说明：<br/>将序列R：5,6,3,6,3,0（第一个5表明后续有5个整数）排序去重后，可得0,3,6。<br/>序列I没有包含0的元素。<br/>序列I中包含3的元素有：I[0]的值为123、I[3]的值为453、I[7]的值为3、I[9]的值为453456、I[13]的值为453、I[14]的值为123。<br/>序列I中包含6的元素有：I[1]的值为456、I[2]的值为786、I[4]的值为46、I[8]的值为665、I[9]的值为453456、I[11]的值为456、I[12]的值为786。<br/>最后按题目要求的格式进行输出即可。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
Is = input().split()[1:]
Rs = list(map(int, input().split()))[1:]

Rs = list(set(Rs))
Rs.sort()

output = []
for r in Rs:
    rs = str(r)
    g = []
    for i, s in enumerate(Is):
        if rs in s:
            g.append(str(i))
            g.append(s)
    if len(g) > 0:
        output.append(rs)
        output.append(str(len(g)//2))
        output.extend(g)

print("{} {}".format(len(output), " ".join(output)))
</pre>
<hr/>
<h1>HJ26 字符串排序</h1>
<p><span class="desc">描述</span><br/>编写一个程序，将输入字符串中的字符按如下规则排序。<br/><br/>规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。<br/><br/>如，输入： Type 输出： epTy<br/><br/>规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。<br/><br/>如，输入： BabA 输出： aABb<br/><br/>规则 3 ：非英文字母的其它字符保持原来的位置。<br/><br/>如，输入： By?e 输出： Be?y<br/><br/>数据范围：输入的字符串长度满足<br/>1≤n≤1000 <br/>输入描述：<br/>输入字符串<br/>输出描述：<br/>输出字符串<br/><span class="example">示例1</span><br/>输入：<br/>A Famous Saying: Much Ado About Nothing (2012/8).<br/>输出：<br/>A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8).</p>
<button onclick='show(event)'>显示代码</button>
<pre>
s = input()

chars = []
puncts = {}

for i, c in enumerate(s):
    if 'a' <= c <= 'z' or 'A' <= c <= 'Z':
        chars.append((c.lower(), i, c))
    else:
        puncts[i] = c

chars.sort()
rst = []
for i in range(len(s)):
    if i in puncts:
        rst.append(puncts[i])
    else:
        rst.append(chars.pop(0)[2])
print("".join(rst))
</pre>
<hr/>
<h1>HJ27 查找兄弟单词</h1>
<p><span class="desc">描述</span><br/>定义一个单词的“兄弟单词”为：交换该单词字母顺序（注：可以交换任意次），而不添加、删除、修改原有的字母就能生成的单词。<br/>兄弟单词要求和原来的单词不同。例如： ab 和 ba 是兄弟单词。 ab 和 ab 则不是兄弟单词。<br/>现在给定你 n 个单词，另外再给你一个单词 x ，让你寻找 x 的兄弟单词里，按字典序排列后的第 k 个单词是什么？<br/>注意：字典中可能有重复单词。<br/><br/>数据范围：<br/>1≤n≤1000 ，输入的字符串长度满足<br/>1 \le len(str) \le 10 \<br/>1≤len(str)≤10  ，<br/>1≤k<n <br/>输入描述：<br/>输入只有一行。 先输入字典中单词的个数n，再输入n个单词作为字典单词。 然后输入一个单词x 最后后输入一个整数k<br/>输出描述：<br/>第一行输出查找到x的兄弟单词的个数m 第二行输出查找到的按照字典顺序排序后的第k个兄弟单词，没有符合第k个的话则不用输出。<br/><span class="example">示例1</span><br/>输入：<br/>3 abc bca cab abc 1<br/>输出：<br/>2<br/>bca<br/><span class="example">示例2</span><br/>输入：<br/>6 cab ad abcd cba abc bca abc 1<br/>输出：<br/>3<br/>bca<br/>说明：<br/>abc的兄弟单词有cab cba bca，所以输出3<br/>经字典序排列后，变为bca cab cba，所以第1个字典序兄弟单词为bca</p>
<button onclick='show(event)'>显示代码</button>
<pre>
data = input().split()

k = int(data.pop())
x = data.pop()
dic = []
xc = "".join(sorted(list(x)))

for w in data[1:]:
    if w != x and "".join(sorted(list(w))) == xc:
        dic.append(w)

dic.sort()
print(len(dic))
if k <= len(dic):
    print(dic[k-1])
</pre>
<hr/>
<h1>HJ28 素数伴侣</h1>
<p><span class="desc">描述</span><br/>题目描述<br/>若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13，它们能应用于通信加密。现在密码学会请你设计一个程序，从已有的 N （ N 为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选方案多种多样，例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会希望你寻找出“最佳方案”。<br/>输入:<br/>有一个正偶数 n ，表示待挑选的自然数的个数。后面给出 n 个具体的数字。<br/>输出:<br/>输出一个整数 K ，表示你求得的“最佳方案”组成“素数伴侣”的对数。<br/><br/>数据范围：<br/>1≤n≤100  ，输入的数据大小满足<br/>2≤val≤30000 <br/>输入描述：<br/>输入说明<br/>1 输入一个正偶数 n<br/>2 输入 n 个整数<br/>输出描述：<br/>求得的“最佳方案”组成“素数伴侣”的对数。<br/><span class="example">示例1</span><br/>输入：<br/>4<br/>2 5 6 13<br/>输出：<br/>2<br/><span class="example">示例2</span><br/>输入：<br/>2<br/>3 6<br/>输出：<br/>0</p>
<button onclick='show(event)'>显示代码</button>
<pre>
_ = int(input())
arr = list(map(int, input().split()))
odd = []
even = []
for e in arr:
    if e % 2 == 0:
        even.append(e)
    else:
        odd.append(e)


def is_prime(n):
    for i in range(2, int(n**(1/2))+1):
        if n % i == 0:
            return False
    return True


pairs = set()
for i in range(len(odd)):
    for j in range(len(even)):
        if is_prime(odd[i] + even[j]):
            pairs.add((i, j))


def find_match(i):
    for j in range(len(even)):
        if (i, j) in pairs and not visit[j]:
            visit[j] = True
            if match[j] == -1 or find_match(match[j]):
                match[j] = i
                return True
    return False


match = [-1] * len(even)
cnt = 0
for i in range(len(odd)):
    visit = [False] * len(even)
    if find_match(i):
        cnt += 1
print(cnt)
</pre>
<hr/>
<h1>HJ29 字符串加解密</h1>
<p><span class="desc">描述</span><br/>对输入的字符串进行加解密，并输出。<br/>加密方法为：<br/>当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a；<br/>当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0；<br/>其他字符不做变化。<br/>解密方法为加密的逆过程。<br/>数据范围：输入的两个字符串长度满足<br/>1≤n≤1000  ，保证输入的字符串都是只由大小写字母或者数字组成<br/>输入描述：<br/>第一行输入一串要加密的密码<br/>第二行输入一串加过密的密码<br/>输出描述：<br/>第一行输出加密后的字符<br/>第二行输出解密后的字符<br/><span class="example">示例1</span><br/>输入：<br/>abcdefg<br/>BCDEFGH<br/>输出：<br/>BCDEFGH<br/>abcdefg</p>
<button onclick='show(event)'>显示代码</button>
<pre>
def encrypt(s):
    r = []
    for c in s:
        if c == 'z':
            r.append('A')
        elif c == 'Z':
            r.append('a')
        elif 'A' <= c <= 'Y' or 'a' <= c <= 'y':
            t = chr(ord(c)+1)
            if 'B' <= t <= 'Z':
                r.append(t.lower())
            else:
                r.append(t.upper())
        elif c in '0123456789':
            r.append(str((int(c) + 1) % 10))
        else:
            r.append(c)
    return "".join(r)

def decrypt(s):
    r = []
    for c in s:
        if c == 'a':
            r.append('Z')
        elif c == 'A':
            r.append('z')
        elif 'B' <= c <= 'Z' or 'b' <= c <= 'z':
            t = chr(ord(c)-1)
            if 'A' <= t <= 'Y':
                r.append(t.lower())
            else:
                r.append(t.upper())
        elif c in '0123456789':
            r.append(str((int(c) + 9) % 10))
        else:
            r.append(c)
    return "".join(r)

s = input()
t = input()
print(encrypt(s))
print(decrypt(t))
</pre>
<hr/>
<h1>HJ30 字符串合并处理</h1>
<p><span class="desc">描述</span><br/>按照指定规则对输入的字符串进行处理。<br/>详细描述：<br/>第一步：将输入的两个字符串str1和str2进行前后合并。如给定字符串 "dec" 和字符串 "fab" ， 合并后生成的字符串为 "decfab"<br/><br/>第二步：对合并后的字符串进行排序，要求为：下标为奇数的字符和下标为偶数的字符分别从小到大排序。这里的下标的意思是字符在字符串中的位置。注意排序后在新串中仍需要保持原来的奇偶性。例如刚刚得到的字符串“decfab”，分别对下标为偶数的字符'd'、'c'、'a'和下标为奇数的字符'e'、'f'、'b'进行排序（生成 'a'、'c'、'd' 和 'b' 、'e' 、'f'），再依次分别放回原串中的偶数位和奇数位，新字符串变为“abcedf”<br/><br/>第三步：对排序后的字符串中的'0'~'9'、'A'~'F'和'a'~'f'字符，需要进行转换操作。<br/>转换规则如下：<br/>对以上需要进行转换的字符所代表的十六进制用二进制表示并倒序，然后再转换成对应的十六进制大写字符（注：字符 a~f 的十六进制对应十进制的10~15，大写同理）。<br/>如字符 '4'，其二进制为 0100 ，则翻转后为 0010 ，也就是 2 。转换后的字符为 '2'。<br/>如字符 ‘7’，其二进制为 0111 ，则翻转后为 1110 ，对应的十进制是14，转换为十六进制的大写字母为 'E'。<br/>如字符 'C'，代表的十进制是 12 ，其二进制为 1100 ，则翻转后为 0011，也就是3。转换后的字符是 '3'。<br/>根据这个转换规则，由第二步生成的字符串 “abcedf” 转换后会生成字符串 "5D37BF"。<br/><br/>数据范围：输入的字符串长度满足<br/>1≤n≤100 <br/><br/>输入描述：<br/>样例输入两个字符串，用空格隔开。<br/>输出描述：<br/>输出转化后的结果。<br/><span class="example">示例1</span><br/>输入：<br/>dec fab<br/>输出：<br/>5D37BF<br/><span class="example">示例2</span><br/>输入：<br/>ab CD<br/>输出：<br/>3B5D<br/>说明：<br/>合并后为abCD，按奇数位和偶数位排序后是CDab（请注意要按ascii码进行排序，所以C在a前面，D在b前面），转换后为3B5D        <br/><span class="example">示例3</span><br/>输入：<br/>123 15<br/>输出：<br/>88C4A</p>
<button onclick='show(event)'>显示代码</button>
<pre>
s = input().replace(' ', '')
even = []
odd = []


for i in range(len(s)):
    if i % 2 == 0:
        even.append(s[i])
    else:
        odd.append(s[i])

even.sort()
odd.sort()

ns = []
for i in range(len(s)):
    if i % 2 == 0:
        c = even[i//2]
    else:
        c = odd[i//2]
    if '0' <= c <= '9' or 'a' <= c <= 'f' or 'A' <= c <= 'F':
        c = hex(int('0b' + bin(int(c, 16))[2:].rjust(4, '0')[::-1], 2))[-1].upper()
    ns.append(c)

print("".join(ns))
</pre>
<hr/>
<h1>HJ31 单词倒排</h1>
<p><span class="desc">描述</span><br/>对字符串中的所有单词进行倒排。<br/>说明：<br/>1、构成单词的字符只有26个大写或小写英文字母；<br/>2、非构成单词的字符均视为单词间隔符；<br/>3、要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符；<br/>4、每个单词最长20个字母；<br/><br/>数据范围：字符串长度满足<br/>1≤n≤10000 <br/>输入描述：<br/>输入一行，表示用来倒排的句子<br/>输出描述：<br/>输出句子的倒排结果<br/><span class="example">示例1</span><br/>输入：<br/>I am a student<br/>输出：<br/>student a am I<br/><span class="example">示例2</span><br/>输入：<br/>$bo*y gi!r#l<br/>输出：<br/>l r gi y bo</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys
import re


print(" ".join(reversed(list(filter(lambda s: s, re.split('\W+', sys.stdin.read()))))))
</pre>
<hr/>
<h1>HJ32 密码截取</h1>
<p><span class="desc">描述</span><br/>Catcher是MCA国的情报员，他工作时发现敌国会用一些对称的密码进行通信，比如像这些ABBA，ABA，A，123321，但是他们有时会在开始或结束时加入一些无关的字符以防止别国破解。比如进行下列变化 ABBA->12ABBA,ABA->ABAKK,123321->51233214　。因为截获的串太长了，而且存在多种可能的情况（abaaab可看作是aba,或baaab的加密形式），Cathcer的工作量实在是太大了，他只能向电脑高手求助，你能帮Catcher找出最长的有效密码串吗？<br/><br/>数据范围：字符串长度满足<br/>1≤n≤2500 <br/>输入描述：<br/>输入一个字符串（字符串的长度不超过2500）<br/>输出描述：<br/>返回有效密码串的最大长度<br/><span class="example">示例1</span><br/>输入：<br/>ABBA<br/>输出：<br/>4<br/><span class="example">示例2</span><br/>输入：<br/>ABBBA<br/>输出：<br/>5<br/><span class="example">示例3</span><br/>输入：<br/>12HHHHA<br/>输出：<br/>4</p>
<button onclick='show(event)'>显示代码</button>
<pre>
def symmetric(s, b, e):
    while b < e:
        if s[b] != s[e]:
            return False
        b += 1
        e -= 1
    return True


s = input()
ml = 1
for i in range(len(s)-2):
    for j in range(len(s)-1, i+1, -1):
        if symmetric(s, i, j):
            ml = max(j - i + 1, ml)
print(ml)
</pre>
<hr/>
<h1>HJ33 整数与IP地址间的转换</h1>
<p><span class="desc">描述</span><br/>原理：ip地址的每段可以看成是一个0-255的整数，把每段拆分成一个二进制形式组合起来，然后把这个二进制数转变成<br/>一个长整数。<br/>举例：一个ip地址为10.0.3.193<br/>每段数字             相对应的二进制数<br/>10                   00001010<br/>0                    00000000<br/>3                    00000011<br/>193                  11000001<br/>组合起来即为：00001010 00000000 00000011 11000001,转换为10进制数就是：167773121，即该IP地址转换后的数字就是它了。<br/><br/>数据范围：保证输入的是合法的 IP 序列<br/><br/>输入描述：<br/>输入 <br/>1 输入IP地址<br/>2 输入10进制型的IP地址<br/>输出描述：<br/>输出<br/>1 输出转换成10进制的IP地址<br/>2 输出转换后的IP地址<br/><span class="example">示例1</span><br/>输入：<br/>10.0.3.193<br/>167969729<br/>输出：<br/>167773121<br/>10.3.3.193</p>
<button onclick='show(event)'>显示代码</button>
<pre>
ip = input().strip()
dec = 0
weight = 1
for n in ip.split(".")[::-1]:
    dec += int(n) * weight
    weight *= 256
print(dec)
num = int(input().strip())
ip_parts = []
for i in range(4):
    ip_parts.append(str(num % 256))
    num //= 256
print(".".join(ip_parts[::-1]))
</pre>
<hr/>
<h1>HJ34 图片整理</h1>
<p><span class="desc">描述</span><br/>Lily上课时使用字母数字图片教小朋友们学习英语单词，每次都需要把这些图片按照大小（ASCII码值从小到大）排列收好。请大家给Lily帮忙，通过代码解决。<br/>Lily使用的图片使用字符"A"到"Z"、"a"到"z"、"0"到"9"表示。<br/><br/>数据范围：每组输入的字符串长度满足<br/>1≤n≤1000 <br/>输入描述：<br/>一行，一个字符串，字符串中的每个字符表示一张Lily使用的图片。<br/>输出描述：<br/>Lily的所有图片按照从小到大的顺序输出<br/><span class="example">示例1</span><br/>输入：<br/>Ihave1nose2hands10fingers<br/>输出：<br/>0112Iaadeeefghhinnnorsssv</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


print("".join(sorted(list(sys.stdin.read().strip()))))
</pre>
<hr/>
<h1>HJ35 蛇形矩阵</h1>
<p><span class="desc">描述</span><br/>蛇形矩阵是由1开始的自然数依次排列成的一个矩阵上三角形。<br/>例如，当输入5时，应该输出的三角形为：<br/>1 3 6 10 15<br/>2 5 9 14<br/>4 8 13<br/>7 12<br/>11<br/><br/><br/>输入描述：<br/>输入正整数N（N不大于100）<br/>输出描述：<br/>输出一个N行的蛇形矩阵。<br/><span class="example">示例1</span><br/>输入：<br/>4<br/>输出：<br/>1 3 6 10<br/>2 5 9<br/>4 8<br/>7</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


n = int(input())

arr = [[0] * n for _ in range(n)]
number = 1
for i in range(n):
    idx = [i, 0]
    arr[idx[0]][idx[1]] = number
    number += 1
    while idx[0] > 0:
        idx = [idx[0]-1, idx[1]+1]
        arr[idx[0]][idx[1]] = number
        number += 1
for l in arr:
    print(" ".join([str(n) for n in l if n]))
</pre>
<hr/>
<h1>HJ36 字符串加密</h1>
<p><span class="desc">描述</span><br/>有一种技巧可以对数据进行加密，它使用一个单词作为它的密匙。下面是它的工作原理：首先，选择一个单词作为密匙，如TRAILBLAZERS。如果单词中包含有重复的字母，只保留第1个，将所得结果作为新字母表开头，并将新建立的字母表中未出现的字母按照正常字母表顺序加入新字母表。如下所示：<br/>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br/>T R A I L B Z E S C D F G H J K M N O P Q U V W X Y (实际需建立小写字母的字母表，此字母表仅为方便演示）<br/>上面其他用字母表中剩余的字母填充完整。在对信息进行加密时，信息中的每个字母被固定于顶上那行，并用下面那行的对应字母一一取代原文的字母(字母字符的大小写状态应该保留)。因此，使用这个密匙， Attack AT DAWN (黎明时攻击)就会被加密为Tpptad TP ITVH。<br/>请实现下述接口，通过指定的密匙和明文得到密文。<br/>数据范围：<br/>1≤n≤100  ，保证输入的字符串中仅包含小写字母<br/>输入描述：<br/>先输入key和要加密的字符串<br/>输出描述：<br/>返回加密后的字符串<br/><span class="example">示例1</span><br/>输入：<br/>nihao<br/>ni<br/>输出：<br/>le</p>
<button onclick='show(event)'>显示代码</button>
<pre>
key = input().strip()
plain = input().strip()

chars = "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z".lower().split()
uk = []

for k in key:
    if k not in uk:
        uk.append(k)

for ch in chars:
    if ch not in uk:
        uk.append(ch)

cm = dict(zip(chars, uk))
ss = []
for ch in plain:
    ss.append(cm[ch])
print("".join(ss))
</pre>
<hr/>
<h1>HJ37 统计每个月兔子的总数</h1>
<p><span class="desc">描述</span><br/>有一种兔子，从出生后第3个月起每个月都生一只兔子，小兔子长到第三个月后每个月又生一只兔子。<br/>例子：假设一只兔子第3个月出生，那么它第5个月开始会每个月生一只兔子。<br/>一月的时候有一只兔子，假如兔子都不死，问第n个月的兔子总数为多少？<br/>数据范围：输入满足<br/>1≤n≤31 <br/>输入描述：<br/>输入一个int型整数表示第n个月<br/>输出描述：<br/>输出对应的兔子总数<br/><span class="example">示例1</span><br/>输入：<br/>3<br/>输出：<br/>2</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())
arr = [1] * n
for i in range(2, n):
    arr[i] = arr[i-1] + arr[i-2]
print(arr[-1])
</pre>
<hr/>
<h1>HJ38 求小球落地5次后所经历的路程和第5次反弹的高度</h1>
<p><span class="desc">描述</span><br/>假设一个球从任意高度自由落下，每次落地后反跳回原高度的一半; 再落下, 求它在第5次落地时，共经历多少米?第5次反弹多高？<br/><br/>数据范围：输入的小球初始高度满足<br/>1≤n≤1000  ，且保证是一个整数<br/>输入描述：<br/>输入起始高度，int型<br/>输出描述：<br/>分别输出第5次落地时，共经过多少米以及第5次反弹多高。<br/>注意：你可以认为你输出保留六位或以上小数的结果可以通过此题。<br/><span class="example">示例1</span><br/>输入：<br/>1<br/>输出：<br/>2.875<br/>0.03125</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())

s = n * (1 + 1 + 1/2 + 1/4 + 1/8)
h = n * (1/pow(2, 5))
print(s)
print(h)
</pre>
<hr/>
<h1>HJ39 判断两个IP是否属于同一子网</h1>
<p><span class="desc">描述</span><br/>IP地址是由4个0-255之间的整数构成的，用"."符号相连。<br/>二进制的IP地址格式有32位，例如：10000011，01101011，00000011，00011000;每八位用十进制表示就是131.107.3.24<br/>子网掩码是用来判断任意两台计算机的IP地址是否属于同一子网络的根据。<br/>子网掩码与IP地址结构相同，是32位二进制数，由1和0组成，且1和0分别连续，其中网络号部分全为“1”和主机号部分全为“0”。<br/>你可以简单的认为子网掩码是一串连续的1和一串连续的0拼接而成的32位二进制数，左边部分都是1，右边部分都是0。<br/>利用子网掩码可以判断两台主机是否在同一子网中。<br/>若两台主机的IP地址分别与它们的子网掩码进行逻辑“与”运算（按位与/AND）后的结果相同，则说明这两台主机在同一子网中。<br/><br/>示例：<br/>I P 地址　 192.168.0.1<br/>子网掩码　 255.255.255.0<br/>转化为二进制进行运算：<br/>I P 地址　  11000000.10101000.00000000.00000001<br/>子网掩码　11111111.11111111.11111111.00000000<br/>AND运算   11000000.10101000.00000000.00000000<br/>转化为十进制后为：<br/>192.168.0.0<br/><br/>I P 地址　 192.168.0.254<br/>子网掩码　 255.255.255.0<br/><br/>转化为二进制进行运算：<br/>I P 地址　11000000.10101000.00000000.11111110<br/>子网掩码  11111111.11111111.11111111.00000000<br/>AND运算  11000000.10101000.00000000.00000000<br/>转化为十进制后为：<br/>192.168.0.0<br/>通过以上对两台计算机IP地址与子网掩码的AND运算后，我们可以看到它运算结果是一样的。均为192.168.0.0，所以这二台计算机可视为是同一子网络。<br/><br/>输入一个子网掩码以及两个ip地址，判断这两个ip地址是否是一个子网络。<br/>若IP地址或子网掩码格式非法则输出1，若IP1与IP2属于同一子网络输出0，若IP1与IP2不属于同一子网络输出2。<br/><br/>注:<br/>有效掩码与IP的性质为：<br/>1. 掩码与IP每一段在 0 - 255 之间<br/>2. 掩码的二进制字符串前缀为网络号，都由‘1’组成；后缀为主机号，都由'0'组成<br/><br/>输入描述：<br/>3行输入，第1行是输入子网掩码、第2，3行是输入两个ip地址<br/>题目的示例中给出了三组数据，但是在实际提交时，你的程序可以只处理一组数据（3行）。<br/>输出描述：<br/>若IP地址或子网掩码格式非法则输出1，若IP1与IP2属于同一子网络输出0，若IP1与IP2不属于同一子网络输出2<br/><span class="example">示例1</span><br/>输入：<br/>255.255.255.0<br/>192.168.224.256<br/>192.168.10.4<br/>255.0.0.0<br/>193.194.202.15<br/>232.43.7.59<br/>255.255.255.0<br/>192.168.0.254<br/>192.168.0.1<br/>输出：<br/>1<br/>2<br/>0<br/>说明：<br/>对于第一个例子:<br/>255.255.255.0<br/>192.168.224.256<br/>192.168.10.4<br/>其中IP:192.168.224.256不合法，输出1<br/><br/>对于第二个例子:<br/>255.0.0.0<br/>193.194.202.15<br/>232.43.7.59<br/>2个与运算之后，不在同一个子网，输出2<br/><br/>对于第三个例子，2个与运算之后，如题目描述所示，在同一个子网，输出0</p>
<button onclick='show(event)'>显示代码</button>
<pre>
def to_number(ip):
    nums = list(map(int, ip.split(".")[::-1]))
    weight = 1
    rst = 0
    for n in nums:
        if not 0 <= n < 256:
            return -1
        rst += n * weight
        weight *= 256
    return rst


def check_mask(v):
    s = bin(v)[2:]
    return len(s) == 32 and s.lstrip("1").rstrip("0") == ""


while True:
    try:
        mask = to_number(input())
        ip1 = to_number(input())
        ip2 = to_number(input())

        if mask < 0 or ip1 < 0 or ip2 < 0 or not check_mask(mask):
            print("1")
        else:
            if mask & ip1 == mask & ip2:
                print("0")
            else:
                print("2")
    except Exception as e:
        break
</pre>
<hr/>
<h1>HJ40 统计字符</h1>
<p><span class="desc">描述</span><br/>输入一行字符，分别统计出包含英文字母、空格、数字和其它字符的个数。<br/>数据范围：输入的字符串长度满足<br/>1≤n≤1000 <br/>输入描述：<br/>输入一行字符串，可以有空格<br/>输出描述：<br/>统计其中英文字符，空格字符，数字字符，其他字符的个数<br/><span class="example">示例1</span><br/>输入：<br/>1qazxsw23 edcvfr45tgbn hy67uj m,ki89ol.\\/;p0-=\\][<br/>输出：<br/>26<br/>3<br/>10<br/>12</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys

cn, sn, nn, en = 0, 0, 0, 0

for c in sys.stdin.read().rstrip('\n'):
    if ' ' == c:
        sn += 1
    elif 'a' <= c <= 'z' or 'A' <= c <= 'Z':
        cn += 1
    elif '0' <= c <= '9':
        nn += 1
    else:
        en += 1

print("\n".join(map(str, [cn, sn, nn, en])))
</pre>
<hr/>
<h1>HJ41 称砝码</h1>
<p><span class="desc">描述</span><br/>现有n种砝码，重量互不相等，分别为 m1,m2,m3…mn ；<br/>每种砝码对应的数量为 x1,x2,x3...xn 。现在要用这些砝码去称物体的重量(放在同一侧)，问能称出多少种不同的重量。<br/>注：<br/>称重重量包括 0<br/><br/>数据范围：每组输入数据满足<br/>1≤n≤10  ，<br/>1≤m<br/>i<br/>≤2000  ，<br/>1≤x<br/>i<br/>≤10 <br/>输入描述：<br/>对于每组测试数据：<br/>第一行：n --- 砝码的种数(范围[1,10])<br/>第二行：m1 m2 m3 ... mn --- 每种砝码的重量(范围[1,2000])<br/>第三行：x1 x2 x3 .... xn --- 每种砝码对应的数量(范围[1,10])<br/>输出描述：<br/>利用给定的砝码可以称出的不同的重量数<br/><span class="example">示例1</span><br/>输入：<br/>2<br/>1 2<br/>2 1<br/>输出：<br/>5<br/>说明：<br/>可以表示出0，1，2，3，4五种重量。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
_ = input()
weights = list(map(int, input().strip().split()))
nums = list(map(int, input().strip().split()))

ws = []
for i in range(len(nums)):
    ws.extend([weights[i]] * nums[i])

uw = set([0])
for w in ws:
    nw = {s+w for s in uw}
    uw = uw.union(nw)
print(len(uw))
</pre>
<hr/>
<h1>HJ42 学英语</h1>
<p><span class="desc">描述</span><br/>Jessi初学英语，为了快速读出一串数字，编写程序将数字转换成英文：<br/><br/>具体规则如下:<br/>1.在英语读法中三位数字看成一整体，后面再加一个计数单位。从最右边往左数，三位一单位，例如12,345 等<br/>2.每三位数后记得带上计数单位 分别是thousand, million, billion.<br/>3.公式：百万以下千以上的数 X thousand X, 10亿以下百万以上的数：X million X thousand X, 10 亿以上的数：X billion X million X thousand X. 每个X分别代表三位数或两位数或一位数。<br/>4.在英式英语中百位数和十位数之间要加and，美式英语中则会省略，我们这个题目采用加上and，百分位为零的话，这道题目我们省略and<br/><br/>下面再看几个数字例句：<br/>22: twenty two<br/>100:  one hundred<br/>145:  one hundred and forty five<br/>1,234:  one thousand two hundred and thirty four<br/>8,088:  eight thousand (and) eighty eight (注:这个and可加可不加，这个题目我们选择不加)<br/>486,669:  four hundred and eighty six thousand six hundred and sixty nine<br/>1,652,510:  one million six hundred and fifty two thousand five hundred and ten<br/><br/>说明：<br/>数字为正整数，不考虑小数，转化结果为英文小写；<br/>保证输入的数据合法<br/>关键字提示：and，billion，million，thousand，hundred。<br/><br/>数据范围：<br/>1≤n≤2000000 <br/><br/><br/>输入描述：<br/>输入一个long型整数<br/>输出描述：<br/>输出相应的英文写法<br/><span class="example">示例1</span><br/>输入：<br/>22<br/>输出：<br/>twenty two</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())

def get_number(n):
    m1 = {
        1: "one",
        2: "two",
        3: "three",
        4: "four",
        5: "five",
        6: "six",
        7: "seven",
        8: "eight",
        9: "nine",
    }
    m2 = {
        10: "ten",
        11: "eleven",
        12: "twelve",
        13: "thirteen",
        14: "fourteen",
        15: "fifteen",
        16: "sixteen",
        17: "seventeen",
        18: "eighteen",
        19: "nineteen",
    }
    m3 = {
        20: "twenty",
        30: "thirty",
        40: "forty",
        50: "fifty",
        60: "sixty",
        70: "seventy",
        80: "eighty",
        90: "ninety",
    }
    s = []
    if n // 100 > 0:
        s.extend([m1[n//100], "hundred"])
    n %= 100
    if n > 0:
        if s:
            s.append("and")
        if n // 10 > 1:
            s.append(m3[n//10*10])
            n %= 10
            if n > 0:
                s.append(m1[n])
        elif n // 10 == 1:
            s.append(m2[n])
        else:
            s.append(m1[n])
    return " ".join(s)


parts = [("billion", 1000 * 1000 * 1000), ("million", 1000 * 1000), ("thousand", 1000), ("", 0)]
rst = []
for p in parts:
    if n >= p[1]:
        rst.append(get_number(n // p[1] if p[1] > 0 else n))
        if p[0]:
            rst.append(p[0])
        if p[1] > 0:
            n %= p[1]

print(" ".join(rst))
</pre>
<hr/>
<h1>HJ43 迷宫问题</h1>
<p><span class="desc">描述</span><br/>定义一个二维数组 N*M ，如 5 × 5 数组下所示：<br/><br/>int maze[5][5] = {<br/>0, 1, 0, 0, 0,<br/>0, 1, 1, 1, 0,<br/>0, 0, 0, 0, 0,<br/>0, 1, 1, 1, 0,<br/>0, 0, 0, 1, 0,<br/>};<br/><br/>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。<br/><br/>数据范围：<br/>2≤n,m≤10  ， 输入的内容只包含<br/>0≤val≤1 <br/>输入描述：<br/>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。<br/>输出描述：<br/>左上角到右下角的最短路径，格式如样例所示。<br/><span class="example">示例1</span><br/>输入：<br/>5 5<br/>0 1 0 0 0<br/>0 1 1 1 0<br/>0 0 0 0 0<br/>0 1 1 1 0<br/>0 0 0 1 0<br/>输出：<br/>(0,0)<br/>(1,0)<br/>(2,0)<br/>(2,1)<br/>(2,2)<br/>(2,3)<br/>(2,4)<br/>(3,4)<br/>(4,4)<br/><span class="example">示例2</span><br/>输入：<br/>5 5<br/>0 1 0 0 0<br/>0 1 0 1 0<br/>0 0 0 0 1<br/>0 1 1 1 0<br/>0 0 0 0 0<br/>输出：<br/>(0,0)<br/>(1,0)<br/>(2,0)<br/>(3,0)<br/>(4,0)<br/>(4,1)<br/>(4,2)<br/>(4,3)<br/>(4,4)<br/>说明：<br/>注意：不能斜着走！！</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


data = [list(map(int, line.split())) for line in sys.stdin.read().strip().split("\n")[1:]]
m = len(data)
n = len(data[0])


routes = []


def walk(hist):
    if hist[-1] == (m-1, n-1):
        routes.append(hist)
        return
    for p in ((0, 1), (0, -1), (1, 0), (-1, 0)):
        np = (hist[-1][0] + p[0], hist[-1][1] + p[1])
        if 0 <= np[0] < m and 0 <= np[1] < n and np not in hist and data[np[0]][np[1]] == 0:
            walk(hist + [np])


walk([(0, 0)])


rst = routes[0]
for r in routes[1:]:
    if len(r[0]) < len(rst):
        rst = r


for p in rst:
    print("({},{})".format(*p))
</pre>
<hr/>
<h1>HJ44 Sudoku</h1>
<p><span class="desc">描述</span><br/>问题描述：数独（Sudoku）是一款大众喜爱的数字逻辑游戏。玩家需要根据9X9盘面上的已知数字，推算出所有剩余空格的数字，并且满足每一行、每一列、每一个3X3粗线宫内的数字均含1-9，并且不重复。<br/>例如：<br/>输入<br/><br/>输出<br/><br/><br/>数据范围：输入一个 9*9 的矩阵<br/>输入描述：<br/>包含已知数字的9X9盘面数组[空缺位以数字0表示]<br/>输出描述：<br/>完整的9X9盘面数组<br/><span class="example">示例1</span><br/>输入：<br/>0 9 2 4 8 1 7 6 3<br/>4 1 3 7 6 2 9 8 5<br/>8 6 7 3 5 9 4 1 2<br/>6 2 4 1 9 5 3 7 8<br/>7 5 9 8 4 3 1 2 6<br/>1 3 8 6 2 7 5 9 4<br/>2 7 1 5 3 8 6 4 9<br/>3 8 6 9 1 4 2 5 7<br/>0 4 5 2 7 6 8 3 1<br/>输出：<br/>5 9 2 4 8 1 7 6 3<br/>4 1 3 7 6 2 9 8 5<br/>8 6 7 3 5 9 4 1 2<br/>6 2 4 1 9 5 3 7 8<br/>7 5 9 8 4 3 1 2 6<br/>1 3 8 6 2 7 5 9 4<br/>2 7 1 5 3 8 6 4 9<br/>3 8 6 9 1 4 2 5 7<br/>9 4 5 2 7 6 8 3 1</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


arr = [list(map(int, r.split())) for r in sys.stdin.read().strip().split("\n")]


def get_cand(i, j):
    used = set()
    for k in range(9):
        used.add(arr[i][k])
        used.add(arr[k][j])
    x, y = (i//3)*3, (j//3)*3
    for s in range(x, x+3):
        for t in range(y, y+3):
            used.add(arr[s][t])
    return list(set(range(1, 10)) - used)


def sudoku(arr):
    for i in range(len(arr)):
        for j in range(len(arr[i])):
            if 0 == arr[i][j]:
                cands = get_cand(i, j)
                for n in cands:
                    arr[i][j] = n
                    if sudoku(arr):
                        return True
                    arr[i][j] = 0
                return False
    return True


rst = sudoku(arr)
if rst:
    for r in arr:
        print(" ".join(map(str, r)))
</pre>
<hr/>
<h1>HJ45 名字的漂亮度</h1>
<p><span class="desc">描述</span><br/>给出一个字符串，该字符串仅由小写字母组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。<br/>每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个不同字母拥有相同的“漂亮度”。字母忽略大小写。<br/>给出多个字符串，计算每个字符串最大可能的“漂亮度”。<br/><br/>本题含有多组数据。<br/><br/>数据范围：输入的名字长度满足<br/>1≤n≤10000 <br/><br/>输入描述：<br/>第一行一个整数N，接下来N行每行一个字符串<br/>输出描述：<br/>每个字符串可能的最大漂亮程度<br/><span class="example">示例1</span><br/>输入：<br/>2<br/>zhangsan<br/>lisi<br/>输出：<br/>192<br/>101<br/>说明：<br/>对于样例lisi，让i的漂亮度为26，l的漂亮度为25，s的漂亮度为24，lisi的漂亮度为25+26+24+26=101.</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())

for i in range(n):
    s = input()
    occurs = {}

    for c in s:
        occurs[c] = occurs.get(c, 0) + 1

    chars = [-occurs[k] for k in occurs]
    chars.sort()

    beauty_degree = 0
    for i in range(len(chars)):
        beauty_degree += (26 - i)*(-chars[i])
    print(beauty_degree)
</pre>
<hr/>
<h1>HJ46 截取字符串</h1>
<p><span class="desc">描述</span><br/>输入一个字符串和一个整数 k ，截取字符串的前k个字符并输出<br/><br/>数据范围：字符串长度满足<br/>1≤n≤1000  ，<br/>1≤k≤n <br/>输入描述：<br/>1.输入待截取的字符串<br/>2.输入一个正整数k，代表截取的长度<br/>输出描述：<br/>截取后的字符串<br/><span class="example">示例1</span><br/>输入：<br/>abABCcDEF<br/>6<br/>输出：<br/>abABCc<br/><span class="example">示例2</span><br/>输入：<br/>bdxPKBhih<br/>6<br/>输出：<br/>bdxPKB</p>
<button onclick='show(event)'>显示代码</button>
<pre>
s = input()
n = int(input())
print(s[:n])
</pre>
<hr/>
<h1>HJ48 从单向链表中删除指定值的节点</h1>
<p><span class="desc">描述</span><br/>输入一个单向链表和一个节点的值，从单向链表中删除等于该值的节点，删除后如果链表中无节点则返回空指针。<br/>链表的值不能重复。<br/>构造过程，例如输入一行数据为:<br/>6 2 1 2 3 2 5 1 4 5 7 2 2<br/>则第一个参数6表示输入总共6个节点，第二个参数2表示头节点值为2，剩下的2个一组表示第2个节点值后面插入第1个节点值，为以下表示:<br/>1 2 表示为<br/>2->1<br/>链表为2->1<br/><br/>3 2表示为<br/>2->3<br/>链表为2->3->1<br/><br/>5 1表示为<br/>1->5<br/>链表为2->3->1->5<br/><br/>4 5表示为<br/>5->4<br/>链表为2->3->1->5->4<br/><br/>7 2表示为<br/>2->7<br/>链表为2->7->3->1->5->4<br/><br/>最后的链表的顺序为 2 7 3 1 5 4<br/><br/>最后一个参数为2，表示要删掉节点为2的值<br/>删除 结点 2<br/>则结果为 7 3 1 5 4<br/><br/>数据范围：链表长度满足<br/>1≤n≤1000  ，节点中的值满足<br/>0≤val≤10000 <br/><br/>测试用例保证输入合法<br/><br/>输入描述：<br/>输入一行，有以下4个部分：<br/>1 输入链表结点个数<br/>2 输入头结点的值<br/>3 按照格式插入各个结点<br/>4 输入要删除的结点的值<br/>输出描述：<br/>输出一行<br/>输出删除结点后的序列，每个数后都要加空格<br/><span class="example">示例1</span><br/>输入：<br/>5 2 3 2 4 3 5 2 1 4 3<br/>输出：<br/>2 5 4 1<br/>说明：<br/>形成的链表为2->5->3->4->1<br/>删掉节点3，返回的就是2->5->4->1 <br/><span class="example">示例2</span><br/>输入：<br/>6 2 1 2 3 2 5 1 4 5 7 2 2<br/>输出：<br/>7 3 1 5 4<br/>说明：<br/>如题</p>
<button onclick='show(event)'>显示代码</button>
<pre>
ns = list(map(int, input().strip().split()))


rst = []
rst.append(ns[1])
dv = ns.pop()
for i in range(2, len(ns), 2):
    v = ns[i]
    b = ns[i+1]
    idx = rst.index(b)
    rst = rst[:idx+1] + [v] + rst[idx+1:]
res = [str(v) for v in rst if v != dv]
print(" ".join(res))
</pre>
<hr/>
<h1>HJ50 四则运算</h1>
<p><span class="desc">描述</span><br/>输入一个表达式（用字符串表示），求这个表达式的值。<br/>保证字符串中的有效字符包括[‘0’-‘9’],‘+’,‘-’, ‘*’,‘/’ ,‘(’， ‘)’,‘[’, ‘]’,‘{’ ,‘}’。且表达式一定合法。<br/><br/>数据范围：表达式计算结果和过程中满足<br/>∣val∣≤1000  ，字符串长度满足<br/>1≤n≤1000 <br/>输入描述：<br/>输入一个算术表达式<br/>输出描述：<br/>得到计算结果<br/><span class="example">示例1</span><br/>输入：<br/>3+2*{1+2*[-4/(8-6)+7]}<br/>输出：<br/>25</p>
<button onclick='show(event)'>显示代码</button>
<pre>
expr = input()
for p in (("[", "("), ("]", ")"), ("{", "("), ("}", ")"), ("/", "//")):
    expr = expr.replace(*p)
print(eval(expr))
</pre>
<hr/>
<h1>HJ51 输出单向链表中倒数第k个结点</h1>
<p><span class="desc">描述</span><br/>输入一个单向链表，输出该链表中倒数第k个结点，链表的倒数第1个结点为链表的尾指针。<br/>链表结点定义如下：<br/>struct ListNode<br/>{<br/>    int m_nKey;<br/>    ListNode* m_pNext;<br/>};<br/>正常返回倒数第k个结点指针，异常返回空指针.<br/>要求：<br/>(1)正序构建链表;<br/>(2)构建后要忘记链表长度。<br/>数据范围：链表长度满足<br/>1≤n≤1000  ，<br/>k≤n  ，链表中数据满足<br/>0≤val≤10000 <br/><br/>本题有多组样例输入。<br/><br/><br/>输入描述：<br/>输入说明<br/>1 输入链表结点个数<br/>2 输入链表的值<br/>3 输入k的值<br/>输出描述：<br/>输出一个整数<br/><span class="example">示例1</span><br/>输入：<br/>8<br/>1 2 3 4 5 6 7 8<br/>4<br/>输出：<br/>5</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


data = sys.stdin.read().strip().split("\n")
while data:
    n = int(data.pop(0))
    arr = data.pop(0).strip().split()
    i = int(data.pop(0))
    print(arr[-i])
</pre>
<hr/>
<h1>HJ52 计算字符串的编辑距离</h1>
<p><span class="desc">描述</span><br/>Levenshtein 距离，又称编辑距离，指的是两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。编辑距离的算法是首先由俄国科学家 Levenshtein 提出的，故又叫 Levenshtein Distance 。<br/>例如：<br/>字符串A: abcdefg<br/>字符串B: abcdef<br/>通过增加或是删掉字符 ”g” 的方式达到目的。这两种方案都需要一次操作。把这个操作所需要的次数定义为两个字符串的距离。<br/>要求：<br/>给定任意两个字符串，写出一个算法计算它们的编辑距离。<br/><br/>数据范围：给定的字符串长度满足<br/>1 \le len(str) \le 1000 \<br/>1≤len(str)≤1000 <br/><br/><br/>输入描述：<br/>每组用例一共2行，为输入的两个字符串<br/>输出描述：<br/>每组用例输出一行，代表字符串的距离<br/><span class="example">示例1</span><br/>输入：<br/>abcdefg<br/>abcdef<br/>输出：<br/>1</p>
<button onclick='show(event)'>显示代码</button>
<pre>
a = input()
b = input()

dp = [[0] * (len(b)+1) for _ in range(len(a)+1)]

for j in range(len(b)+1):
    dp[0][j] = j

for i in range(1, len(a)+1):
    dp[i][0] = i
    for j in range(1, len(b)+1):
        if a[i-1] == b[j-1]:
            dp[i][j] = dp[i-1][j-1]
        else:
            dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1])+1

print(dp[len(a)][len(b)])
</pre>
<hr/>
<h1>HJ53 杨辉三角的变形</h1>
<p><span class="desc">描述</span><br/>以上三角形的数阵，第一行只有一个数1，以下每行的每个数，是恰好是它上面的数、左上角数和右上角的数，3个数之和（如果不存在某个数，认为该数就是0）。<br/>求第n行第一个偶数出现的位置。如果没有偶数，则输出-1。例如输入3,则输出2，输入4则输出3，输入2则输出-1。<br/>数据范围：<br/>1 \le n \le 10^9 \<br/>1≤n≤10<br/>9<br/>  输入描述：<br/>输入一个int整数<br/>输出描述：<br/>输出返回的int值<br/><span class="example">示例1</span><br/>输入：<br/>4<br/>输出：<br/>3</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())

print(-1 if n < 3 else [2, 3, 2, 4][(n - 3) % 4])
</pre>
<hr/>
<h1>HJ54 表达式求值</h1>
<p><span class="desc">描述</span><br/>给定一个字符串描述的算术表达式，计算出结果值。<br/>输入字符串长度不超过 100 ，合法的字符包括 ”+, -, *, /, (, )” ， ”0-9” 。<br/><br/>数据范围：运算过程中和最终结果均满足<br/>|val| \le 2^{31}-1 \<br/>∣val∣≤2<br/>31<br/>−1  ，即只进行整型运算，确保输入的表达式合法<br/>输入描述：<br/>输入算术表达式<br/>输出描述：<br/>计算出结果值<br/><span class="example">示例1</span><br/>输入：<br/>400+5<br/>输出：<br/>405</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


print(eval(sys.stdin.read().replace("/", "//")))
</pre>
<hr/>
<h1>HJ55 挑7</h1>
<p><span class="desc">描述</span><br/>输出 1到n之间 的与 7 有关数字的个数。<br/>一个数与7有关是指这个数是 7 的倍数，或者是包含 7 的数字（如 17 ，27 ，37 ... 70 ，71 ，72 ，73...）<br/><br/>数据范围：<br/>1≤n≤30000 <br/>输入描述：<br/>一个正整数 n 。( n 不大于 30000 )<br/>输出描述：<br/>一个整数，表示1到n之间的与7有关的数字个数。<br/><span class="example">示例1</span><br/>输入：<br/>20<br/>输出：<br/>3<br/>说明：<br/>输入20，1到20之间有关的数字包括7,14,17共3个。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())


num = 0
for i in range(1, n+1):
    if i % 7 == 0 or str(i).count("7") > 0:
        num += 1
print(num)
</pre>
<hr/>
<h1>HJ56 完全数计算</h1>
<p><span class="desc">描述</span><br/>完全数（Perfect number），又称完美数或完备数，是一些特殊的自然数。<br/>它所有的真因子（即除了自身以外的约数）的和（即因子函数），恰好等于它本身。<br/>例如：28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14=28。<br/><br/>输入n，请输出n以内(含n)完全数的个数。<br/><br/>数据范围：<br/>1 \le n \le 5 \times 10^{5} \<br/>1≤n≤5×10<br/>5<br/> <br/>输入描述：<br/>输入一个数字n<br/>输出描述：<br/>输出不超过n的完全数的个数<br/><span class="example">示例1</span><br/>输入：<br/>1000<br/>输出：<br/>3</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


n = int(input())
cnt = 0
for i in range(n):
    tgt = i + 1
    fs = 0
    for j in range(1, tgt):
        if tgt % j == 0:
            fs += j
    if fs == tgt:
        cnt += 1
print(cnt)
</pre>
<hr/>
<h1>HJ57 高精度整数加法</h1>
<p><span class="desc">描述</span><br/>输入两个用字符串 str 表示的整数，求它们所表示的数之和。<br/><br/>数据范围：<br/>1 \le len(str) \le 10000 \<br/>1≤len(str)≤10000 <br/>输入描述：<br/>输入两个字符串。保证字符串只含有'0'~'9'字符<br/>输出描述：<br/>输出求和后的结果<br/><span class="example">示例1</span><br/>输入：<br/>9876543210<br/>1234567890<br/>输出：<br/>11111111100</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n1 = input()
n2 = input()


nl1 = [int(i) for i in n1[::-1]]
nl2 = [int(i) for i in n2[::-1]]

rst = []
i, j = 0, 0
while i < len(nl1) and j < len(nl2):
    rst.append(nl1[i] + nl2[j])
    i += 1
    j += 1
    
while i < len(nl1):
    rst.append(nl1[i])
    i += 1
    
while j < len(nl2):
    rst.append(nl2[j])
    j += 1

for i in range(len(rst)-1):
    if rst[i] > 9:
        rst[i] = rst[i] % 10
        rst[i+1] += 1

if rst[-1] > 9:
    rst[-1] = rst[-1] % 10
    rst.append(1)
print("".join(map(str, reversed(rst))))
</pre>
<hr/>
<h1>HJ58 输入n个整数，输出其中最小的k个</h1>
<p><span class="desc">描述</span><br/>输入n个整数，找出其中最小的k个整数并按升序输出<br/><br/>本题有多组输入样例<br/><br/>数据范围：<br/>1≤n≤1000  ，输入的整数满足<br/>1≤val≤10000 <br/>输入描述：<br/>第一行输入两个整数n和k<br/>第二行输入一个整数数组<br/>输出描述：<br/>从小到大输出最小的k个整数，用空格分开。<br/><span class="example">示例1</span><br/>输入：<br/>5 2<br/>1 3 5 7 2<br/>输出：<br/>1 2</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n, k = list(map(int, input().strip().split()))
arr = list(map(int, input().strip().split()))
arr.sort()
print(" ".join(map(str, arr[:k])))
</pre>
<hr/>
<h1>HJ59 找出字符串中第一个只出现一次的字符</h1>
<p><span class="desc">描述</span><br/>找出字符串中第一个只出现一次的字符<br/><br/><br/>数据范围：输入的字符串长度满足<br/>1≤n≤1000 <br/><br/>输入描述：<br/>输入一个非空字符串<br/>输出描述：<br/>输出第一个只出现一次的字符，如果不存在输出-1<br/><span class="example">示例1</span><br/>输入：<br/>asdfasdfo<br/>输出：<br/>o</p>
<button onclick='show(event)'>显示代码</button>
<pre>
s = input()


for c in s:
    if s.count(c) == 1:
        print(c)
        break
else:
    print("-1")
</pre>
<hr/>
<h1>HJ60 查找组成一个偶数最接近的两个素数</h1>
<p><span class="desc">描述</span><br/>任意一个偶数（大于2）都可以由2个素数组成，组成偶数的2个素数有很多种情况，本题目要求输出组成指定偶数的两个素数差值最小的素数对。<br/><br/>数据范围：输入的数据满足<br/>4≤n≤1000 <br/>输入描述：<br/>输入一个大于2的偶数<br/>输出描述：<br/>从小到大输出两个素数<br/><span class="example">示例1</span><br/>输入：<br/>20<br/>输出：<br/>7<br/>13<br/><span class="example">示例2</span><br/>输入：<br/>4<br/>输出：<br/>2<br/>2</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


n = int(input())
pt = [True] * (n+1)
for i in range(2, n+1):
    if not pt[i]:
        continue
    j = 2
    while j * i < n + 1:
        pt[j * i] = False
        j += 1

half = n // 2
while half > 1:
    if pt[half] and pt[n - half]:
        print("{}\n{}".format(half, n - half))
        break
    half -= 1
</pre>
<hr/>
<h1>HJ61 放苹果</h1>
<p><span class="desc">描述</span><br/>把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？<br/>注意：如果有7个苹果和3个盘子，（5，1，1）和（1，5，1）被视为是同一种分法。<br/><br/>数据范围：<br/>0≤m≤10 ，<br/>1≤n≤10 。<br/><br/>输入描述：<br/>输入两个int整数<br/>输出描述：<br/>输出结果，int型<br/><span class="example">示例1</span><br/>输入：<br/>7 3<br/>输出：<br/>8</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


m, n = list(map(int, sys.stdin.read().strip().split()))

def f(m, n):
    if m < 0 or n < 0:
        return 0
    if m == 1 or n == 1:
        return 1
    return f(m, n-1) + f(m-n, n)

print(f(m, n))
</pre>
<hr/>
<h1>HJ62 查找输入整数二进制中1的个数</h1>
<p><span class="desc">描述</span><br/>输入一个正整数，计算它在二进制下的1的个数。<br/>注意多组输入输出！！！！！！<br/><br/>数据范围：<br/>1 \le n \le 2^{31}-1 \<br/>1≤n≤2<br/>31<br/>−1 <br/>输入描述：<br/>输入一个整数<br/>输出描述：<br/>计算整数二进制中1的个数<br/><span class="example">示例1</span><br/>输入：<br/>5<br/>输出：<br/>2<br/>说明：<br/>5的二进制表示是101，有2个1   <br/><span class="example">示例2</span><br/>输入：<br/>0<br/>输出：<br/>0</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


for line in sys.stdin.read().strip().split("\n"):
    print(bin(int(line)).count("1"))
</pre>
<hr/>
<h1>HJ63 DNA序列</h1>
<p><span class="desc">描述</span><br/>一个 DNA 序列由 A/C/G/T 四个字母的排列组合组成。 G 和 C 的比例（定义为 GC-Ratio ）是序列中 G 和 C 两个字母的总的出现次数除以总的字母数目（也就是序列长度）。在基因工程中，这个比例非常重要。因为高的 GC-Ratio 可能是基因的起始点。<br/>给定一个很长的 DNA 序列，以及限定的子串长度 N ，请帮助研究人员在给出的 DNA 序列中从左往右找出 GC-Ratio 最高且长度为 N 的第一个子串。<br/>DNA序列为 ACGT 的子串有: ACG , CG , CGT 等等，但是没有 AGT ， CT 等等<br/><br/>数据范围：字符串长度满足<br/>1≤n≤1000  ，输入的字符串只包含 A/C/G/T 字母<br/>输入描述：<br/>输入一个string型基因序列，和int型子串的长度<br/>输出描述：<br/>找出GC比例最高的子串,如果有多个则输出第一个的子串<br/><span class="example">示例1</span><br/>输入：<br/>ACGT<br/>2<br/>输出：<br/>CG<br/>说明：<br/>ACGT长度为2的子串有AC,CG,GT3个，其中AC和GT2个的GC-Ratio都为0.5，CG为1，故输出CG   <br/><span class="example">示例2</span><br/>输入：<br/>AACTGTGCACGACCTGA<br/>5<br/>输出：<br/>GCACG<br/>说明：<br/>虽然CGACC的GC-Ratio也是最高，但它是从左往右找到的GC-Ratio最高的第2个子串，所以只能输出GCACG。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
rs = input()
n = int(input())


s = rs.replace("G", "C")
rst = 0
rv = s[:n].count("C")
nv = rv

for i in range(1, len(s)-n):
    if s[i-1] == "C":
        nv -= 1
    if s[i+n-1] == "C":
        nv += 1
    if nv > rv:
        rst = i
        rv = nv
print(rs[rst:rst+n])
</pre>
<hr/>
<h1>HJ64 MP3光标位置</h1>
<p><span class="desc">描述</span><br/>MP3 Player因为屏幕较小，显示歌曲列表的时候每屏只能显示几首歌曲，用户要通过上下键才能浏览所有的歌曲。为了简化处理，假设每屏只能显示4首歌曲，光标初始的位置为第1首歌。<br/>现在要实现通过上下键控制光标移动来浏览歌曲列表，控制逻辑如下：<br/>歌曲总数<=4的时候，不需要翻页，只是挪动光标位置。<br/>光标在第一首歌曲上时，按Up键光标挪到最后一首歌曲；光标在最后一首歌曲时，按Down键光标挪到第一首歌曲。<br/>其他情况下用户按Up键，光标挪到上一首歌曲；用户按Down键，光标挪到下一首歌曲。<br/>2. 歌曲总数大于4的时候（以一共有10首歌为例）：<br/><br/>特殊翻页：屏幕显示的是第一页（即显示第1 – 4首）时，光标在第一首歌曲上，用户按Up键后，屏幕要显示最后一页（即显示第7-10首歌），同时光标放到最后一首歌上。同样的，屏幕显示最后一页时，光标在最后一首歌曲上，用户按Down键，屏幕要显示第一页，光标挪到第一首歌上。<br/>一般翻页：屏幕显示的不是第一页时，光标在当前屏幕显示的第一首歌曲时，用户按Up键后，屏幕从当前歌曲的上一首开始显示，光标也挪到上一首歌曲。光标当前屏幕的最后一首歌时的Down键处理也类似。<br/>其他情况，不用翻页，只是挪动光标就行。<br/>数据范围：命令长度<br/>1≤s≤100 ，歌曲数量<br/>1≤n≤150 <br/>进阶：时间复杂度：<br/>O(n)\<br/>O(n) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>输入说明：<br/>1 输入歌曲数量<br/>2 输入命令 U或者D<br/>输出描述：<br/>输出说明<br/>1 输出当前列表<br/>2 输出当前选中歌曲<br/><span class="example">示例1</span><br/>输入：<br/>10<br/>UUUU<br/>输出：<br/>7 8 9 10<br/>7</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())
cmd = input()

window = list(range(1, min(n+1, 5)))
idx = 0

if n <= 4:
    for c in cmd:
        if c == 'U':
            idx = (idx + n - 1) % n
        else:
            idx = (idx + 1) % n
else:
    for c in cmd:
        nw = []
        if c == 'U':
            if idx == 0:
                if window[idx] == 1:
                    nw = list(range(n-3, n+1))
                    idx = 3
                else:
                    nw.append((window[0]-1+n-1)%n+1)
                    nw.extend(window[:3])
            else:
                idx -= 1
        else:
            if idx == 3:
                if window[idx] == n:
                    nw = list(range(1, 5))
                    idx = 0
                else:
                    nw.extend(window[1:])
                    nw.append((window[-1]-1+1)%n+1)
            else:
                idx += 1
        if nw:
            window = nw

print(" ".join(map(str, window)))
print(window[idx])
</pre>
<hr/>
<h1>HJ65 查找两个字符串a,b中的最长公共子串</h1>
<p><span class="desc">描述</span><br/>查找两个字符串a,b中的最长公共子串。若有多个，输出在较短串中最先出现的那个。<br/>注：子串的定义：将一个字符串删去前缀和后缀（也可以不删）形成的字符串。请和“子序列”的概念分开！<br/><br/>数据范围：字符串长度<br/>1≤length≤300 <br/>进阶：时间复杂度：<br/>O(n^3)\<br/>O(n<br/>3<br/>) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>输入两个字符串<br/>输出描述：<br/>返回重复出现的字符<br/><span class="example">示例1</span><br/>输入：<br/>abcdefghijklmnop<br/>abcsafjklmnopqrstuvw<br/>输出：<br/>jklmnop</p>
<button onclick='show(event)'>显示代码</button>
<pre>
a = input()
b = input()


if len(a) > len(b):
    a, b = b, a


maxsub = None
maxlen = 0
for i in range(len(a)):
    for j in range(i+1, len(a)+1):
        if b.count(a[i:j]) > 0 and j - i > maxlen:
            maxlen = j - i
            maxsub = a[i:j]


print(maxsub)
</pre>
<hr/>
<h1>HJ66 配置文件恢复</h1>
<p><span class="desc">描述</span><br/>有6条配置命令，它们执行的结果分别是：<br/>命   令 执   行<br/>reset reset what<br/>reset board board fault<br/>board add where to add<br/>board delete no board at all<br/>reboot backplane impossible<br/>backplane abort install first<br/>he he unknown command<br/>注意：he he不是命令。<br/>为了简化输入，方便用户，以“最短唯一匹配原则”匹配（注：需从首字母开始进行匹配）：<br/>1、若只输入一字串，则只匹配一个关键字的命令行。例如输入：r，根据该规则，匹配命令reset，执行结果为：reset what；输入：res，根据该规则，匹配命令reset，执行结果为：reset what；<br/>2、若只输入一字串，但匹配命令有两个关键字，则匹配失败。例如输入：reb，可以找到命令reboot backpalne，但是该命令有两个关键词，所有匹配失败，执行结果为：unknown command<br/>3、若输入两字串，则先匹配第一关键字，如果有匹配，继续匹配第二关键字，如果仍不唯一，匹配失败。<br/>例如输入：r b，找到匹配命令reset board 和 reboot backplane，执行结果为：unknown command。<br/>例如输入：b a，无法确定是命令board add还是backplane abort，匹配失败。<br/>4、若输入两字串，则先匹配第一关键字，如果有匹配，继续匹配第二关键字，如果唯一，匹配成功。例如输入：bo a，确定是命令board add，匹配成功。<br/>5、若输入两字串，第一关键字匹配成功，则匹配第二关键字，若无匹配，失败。例如输入：b addr，无法匹配到相应的命令，所以执行结果为：unknow command。<br/>6、若匹配失败，打印“unknown command”<br/>注意：有多组输入。<br/>数据范围：数据组数：<br/>1≤t≤800 ，字符串长度<br/>1≤s≤20 <br/>进阶：时间复杂度：<br/>O(n)\<br/>O(n) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>多行字符串，每行字符串一条命令<br/>输出描述：<br/>执行结果，每条命令输出一行<br/><span class="example">示例1</span><br/>输入：<br/>reset<br/>reset board<br/>board add<br/>board delet<br/>reboot backplane<br/>backplane abort<br/>输出：<br/>reset what<br/>board fault<br/>where to add<br/>no board at all<br/>impossible<br/>install first</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


im = [
    {
        ("reset", ): "reset what"
    },
    {
        ("reset","board"): "board fault",
        ("board","add"): "where to add",
        ("board","delete"): "no board at all",
        ("reboot","backplane"): "impossible",
        ("backplane","abort"): "install first"
    }
]


for line in sys.stdin:
    ui = line.split()
    cands = []
    for p in im[len(ui)-1]:
        for i in range(len(ui)):
            if p[i][:len(ui[i])] != ui[i]:
                break
        else:
            cands.append(im[len(ui)-1][p])


    print(cands[0] if len(cands) == 1 else "unknown command")
</pre>
<hr/>
<h1>HJ67 24点游戏算法</h1>
<p><span class="desc">描述</span><br/>给出4个1-10的数字，通过加减乘除运算，得到数字为24就算胜利,除法指实数除法运算,运算符仅允许出现在两个数字之间,本题对数字选取顺序无要求，但每个数字仅允许使用一次，且需考虑括号运算<br/>此题允许数字重复，如3 3 4 4为合法输入，此输入一共有两个3，但是每个数字只允许使用一次，则运算过程中两个3都被选取并进行对应的计算操作。<br/>输入描述：<br/>读入4个[1,10]的整数，数字允许重复，测试用例保证无异常数字。<br/>输出描述：<br/>对于每组案例，输出一行表示能否得到24点，能输出true，不能输出false<br/><span class="example">示例1</span><br/>输入：<br/>7 2 1 10<br/>输出：<br/>true</p>
<button onclick='show(event)'>显示代码</button>
<pre>
nums = list(map(int, input().split()))


def calc(arr, tgt):
    if len(arr) == 1:
        return abs(arr[0] - tgt) < 1e-6
    for i in range(len(arr)):
        narr = arr[:i] + arr[i+1:]
        n = arr[i]
        if calc(narr, tgt + n) or calc(narr, tgt - n) or calc(narr, tgt * n) or calc(narr, tgt / n):
            return True
    return False


print("true" if calc(nums, 24) else "false")
</pre>
<hr/>
<h1>HJ68 成绩排序</h1>
<p><span class="desc">描述</span><br/>给定一些同学的信息（名字，成绩）序列，请你将他们的信息按照成绩从高到低或从低到高的排列,相同成绩<br/>都按先录入排列在前的规则处理。<br/>例示：<br/>jack      70<br/>peter     96<br/>Tom       70<br/>smith     67<br/>从高到低  成绩<br/>peter     96<br/>jack      70<br/>Tom       70<br/>smith     67<br/>从低到高<br/>smith     67<br/>jack      70<br/>Tom       70<br/>peter     96<br/><br/>注：0代表从高到低，1代表从低到高<br/><br/>数据范围：人数：<br/>1≤n≤200 <br/>进阶：时间复杂度：<br/>O(nlogn)\<br/>O(nlogn) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>第一行输入要排序的人的个数n，第二行输入一个整数表示排序的方式，之后n行分别输入他们的名字和成绩，以一个空格隔开<br/>输出描述：<br/>按照指定方式输出名字和成绩，名字和成绩之间以一个空格隔开<br/><span class="example">示例1</span><br/>输入：<br/>3<br/>0<br/>fang 90<br/>yang 50<br/>ning 70<br/>输出：<br/>fang 90<br/>ning 70<br/>yang 50<br/><span class="example">示例2</span><br/>输入：<br/>3<br/>1<br/>fang 90<br/>yang 50<br/>ning 70<br/>输出：<br/>yang 50<br/>ning 70<br/>fang 90</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())
asc = input()
data = []
for i in range(n):
    name, score = input().split()
    if "1" == asc:
        data.append((int(score), i, name))
    else:
        data.append((-int(score), i, name))
data.sort()
for p in data:
    print("{} {}".format(p[2], p[0] if "1" == asc else -p[0]))
</pre>
<hr/>
<h1>HJ69 矩阵乘法</h1>
<p><span class="desc">描述</span><br/>如果A是个x行y列的矩阵，B是个y行z列的矩阵，把A和B相乘，其结果将是另一个x行z列的矩阵C。这个矩阵的每个元素是由下面的公式决定的<br/><br/>矩阵的大小不超过100*100<br/>输入描述：<br/>第一行包含一个正整数x，代表第一个矩阵的行数<br/>第二行包含一个正整数y，代表第一个矩阵的列数和第二个矩阵的行数<br/>第三行包含一个正整数z，代表第二个矩阵的列数<br/>之后x行，每行y个整数，代表第一个矩阵的值<br/>之后y行，每行z个整数，代表第二个矩阵的值<br/><br/>输出描述：<br/>对于每组输入数据，输出x行，每行z个整数，代表两个矩阵相乘的结果<br/><span class="example">示例1</span><br/>输入：<br/>2<br/>3<br/>2<br/>1 2 3<br/>3 2 1<br/>1 2<br/>2 1<br/>3 3<br/>输出：<br/>14 13<br/>10 11<br/>说明：<br/>1 2 3<br/>3 2 1 <br/>乘以<br/>1 2<br/>2 1<br/>3 3<br/>等于<br/>14 13<br/>10 11    <br/><span class="example">示例2</span><br/>输入：<br/>16<br/>8<br/>7<br/>17 19 16 19 14 1 14 9 <br/>7 2 7 9 16 14 16 12 <br/>13 3 3 17 5 9 8 16 <br/>1 14 16 10 13 13 14 1 <br/>13 13 15 4 7 2 6 16 <br/>16 15 5 5 15 13 1 11 <br/>11 5 0 16 14 7 7 15 <br/>0 16 4 7 16 6 0 15 <br/>2 14 11 2 17 17 5 12 <br/>8 13 11 10 1 17 10 8 <br/>15 16 17 15 7 8 13 14 <br/>5 19 11 3 11 14 5 4 <br/>9 16 13 11 15 18 0 3 <br/>15 3 19 9 5 14 12 3 <br/>9 8 7 11 18 19 14 18 <br/>12 19 9 1 0 18 17 10 <br/>5 18 16 19 6 12 5 <br/>1 17 1 5 9 16 3 <br/>14 16 4 0 19 3 6 <br/>11 9 15 18 11 17 13 <br/>5 5 19 3 16 1 12 <br/>12 13 19 1 10 5 18 <br/>19 18 6 18 19 12 3 <br/>15 11 6 5 10 17 19 <br/>输出：<br/>1020 1490 1063 1100 1376 1219 884<br/>966 1035 1015 715 1112 772 920<br/>822 948 888 816 831 920 863<br/>855 1099 828 578 1160 717 724<br/>745 1076 644 595 930 838 688<br/>635 1051 970 600 880 811 846<br/>748 879 952 772 864 872 878<br/>526 722 645 335 763 688 748<br/>764 996 868 362 1026 681 897<br/>836 1125 785 637 940 849 775<br/>1082 1476 996 968 1301 1183 953<br/>609 987 717 401 894 657 662<br/>700 1083 1022 527 1016 746 875<br/>909 1162 905 722 1055 708 720<br/>1126 1296 1240 824 1304 1031 1196<br/>905 1342 766 715 1028 956 749</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


x = int(input())
y = int(input())
z = int(input())


data = sys.stdin.read().split("\n")

A = [list(map(int, r.split())) for r in data[:x]]
B = [list(map(int, r.split())) for r in data[x:]]
C = []
for i in range(x):
    cr = []
    for j in range(z):
        cv = 0
        for k in range(y):
            cv += A[i][k] * B[k][j]
        cr.append(cv)
    C.append(cr)
for r in C:
    print(" ".join(map(str, r)))
</pre>
<hr/>
<h1>HJ70 矩阵乘法计算量估算</h1>
<p><span class="desc">描述</span><br/>矩阵乘法的运算量与矩阵乘法的顺序强相关。<br/>例如：<br/>A是一个50×10的矩阵，B是10×20的矩阵，C是20×5的矩阵<br/>计算A*B*C有两种顺序：((AB)C)或者(A(BC))，前者需要计算15000次乘法，后者只需要3500次。<br/>编写程序计算不同的计算顺序需要进行的乘法次数。<br/><br/>数据范围：矩阵个数：<br/>1≤n≤15 ，行列数：<br/>1≤row<br/>i<br/>,col<br/>i<br/>≤100 ，保证给出的字符串表示的计算顺序唯一。<br/>进阶：时间复杂度：<br/>O(n)\<br/>O(n) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/><br/>输入描述：<br/>输入多行，先输入要计算乘法的矩阵个数n，每个矩阵的行数，列数，总共2n的数，最后输入要计算的法则<br/>计算的法则为一个字符串，仅由左右括号和大写字母（'A'~'Z'）组成，保证括号是匹配的且输入合法！<br/>输出描述：<br/>输出需要进行的乘法次数<br/><span class="example">示例1</span><br/>输入：<br/>3<br/>50 10<br/>10 20<br/>20 5<br/>(A(BC))<br/>输出：<br/>3500</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


n = int(input())
sz = {}
for i in range(n):
    sz[chr(ord('A')+i)] = list(map(int, input().split()))
rule = input()

mt = 0
opers = []

for c in rule:
    if '(' == c:
        opers.append(c)
        continue
        
    if ')' == c:
        B = opers.pop()
        opers.pop()
        if len(opers) > 0 and opers[-1] != '(' and opers[-1] != ')':
            A = opers.pop()
            mt += A[0] * A[1] * B[1]
            opers.append([A[0], B[1]])
        else:
            opers.append(B)
        continue

    if len(opers) == 0 or opers[-1] == "(":
        opers.append(sz[c])
    else:
        A = opers.pop()
        B = sz[c]
        mt += A[0] * A[1] * B[1]
        opers.append([A[0], B[1]])

print(mt)
</pre>
<hr/>
<h1>HJ71 字符串通配符</h1>
<p><span class="desc">描述</span><br/>问题描述：在计算机中，通配符一种特殊语法，广泛应用于文件搜索、数据库、正则表达式等领域。现要求各位实现字符串通配符的算法。<br/>要求：<br/>实现如下2个通配符：<br/>*：匹配0个或以上的字符（注：能被*和?匹配的字符仅由英文字母和数字0到9组成，下同）<br/>？：匹配1个字符<br/>注意：匹配时不区分大小写。<br/><br/>输入：<br/>通配符表达式；<br/>一组字符串。<br/>输出：<br/>返回不区分大小写的匹配结果，匹配成功输出true，匹配失败输出false<br/>数据范围：字符串长度：<br/>1≤s≤100 <br/>进阶：时间复杂度：<br/>O(n^2)\<br/>O(n<br/>2<br/>) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>先输入一个带有通配符的字符串，再输入一个需要匹配的字符串<br/>输出描述：<br/>返回不区分大小写的匹配结果，匹配成功输出true，匹配失败输出false<br/><span class="example">示例1</span><br/>输入：<br/>te?t*.*<br/>txt12.xls<br/>输出：<br/>false<br/><span class="example">示例2</span><br/>输入：<br/>z<br/>zz<br/>输出：<br/>false<br/><span class="example">示例3</span><br/>输入：<br/>pq<br/>pppq<br/>输出：<br/>false<br/><span class="example">示例4</span><br/>输入：<br/>**Z<br/>0QZz<br/>输出：<br/>true<br/><span class="example">示例5</span><br/>输入：<br/>?*Bc*?<br/>abcd<br/>输出：<br/>true<br/><span class="example">示例6</span><br/>输入：<br/>h*?*a<br/>h#a<br/>输出：<br/>false<br/>说明：<br/>根据题目描述可知能被*和?匹配的字符仅由英文字母和数字0到9组成，所以?不能匹配#，故输出false     <br/><span class="example">示例7</span><br/>输入：<br/>p*p*qp**pq*p**p***ppq<br/>pppppppqppqqppqppppqqqppqppqpqqqppqpqpppqpppqpqqqpqqp<br/>输出：<br/>false</p>
<button onclick='show(event)'>显示代码</button>
<pre>
wildcard = list(input().lower())
plain = list(input().lower())


def ic(c):
    return "a" <= c <= "z" or "0" <= c <= "9"


def wmatch(pt, sl):
    if not pt and not sl:
        return True
    if not pt:
        return False
    if not sl:
        while '*' in pt:
            pt.remove("*")
        return len(pt) == 0
        
    p = pt[-1]
    if p == '?':
        if not ic(sl.pop()):
            return False
        return wmatch(pt[:-1], sl)
    if p == '*':
        i = len(sl)
        while i > 0 and ic(sl[i-1]):
            rst = wmatch(pt[:-1], sl[:i])
            if rst:
                return True
            i -= 1
        return wmatch(pt[:-1], sl[:i])
    if p != sl[-1]:
        return False
    return wmatch(pt[:-1], sl[:-1])


print("true" if wmatch(wildcard, plain) else "false")
</pre>
<hr/>
<h1>HJ72 百钱买百鸡问题</h1>
<p><span class="desc">描述</span><br/>公元五世纪，我国古代数学家张丘建在《算经》一书中提出了“百鸡问题”：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？<br/>现要求你打印出所有花一百元买一百只鸡的方式。<br/>输入描述：<br/>输入任何一个整数，即可运行程序。<br/>输出描述：<br/> 输出有数行，每行三个整数，分别代表鸡翁，母鸡，鸡雏的数量<br/><span class="example">示例1</span><br/>输入：<br/>1<br/>输出：<br/>0 25 75<br/>4 18 78<br/>8 11 81<br/>12 4 84</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = 100
for i in range(n // 5):
    for j in range((n - i * 5) // 3):
        k = (n - i * 5 - j * 3) * 3
        if k + i + j == n:
            print("{} {} {}".format(i, j, k))
</pre>
<hr/>
<h1>HJ73 计算日期到天数转换</h1>
<p><span class="desc">描述</span><br/>根据输入的日期，计算是这一年的第几天。<br/>保证年份为4位数且日期合法。<br/>进阶：时间复杂度：<br/>O(n)\<br/>O(n) ，空间复杂度：<br/>O(1)\<br/>O(1) <br/>输入描述：<br/>输入一行，每行空格分割，分别是年，月，日<br/>输出描述：<br/>输出是这一年的第几天<br/><span class="example">示例1</span><br/>输入：<br/>2012 12 31<br/>输出：<br/>366<br/><span class="example">示例2</span><br/>输入：<br/>1982 3 4<br/>输出：<br/>63</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


dom = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

y, m, d = list(map(int, sys.stdin.read().strip().split()))

if y % 400 == 0 or (y % 100 != 0 and y % 4 == 0):
    dom[1] = 29

td = 0
for i in range(m-1):
    td += dom[i]
td += d
print(td)
</pre>
<hr/>
<h1>HJ74 参数解析</h1>
<p><span class="desc">描述</span><br/>在命令行输入如下命令：<br/>xcopy /s c:\\ d:\\e，<br/>各个参数如下：<br/>参数1：命令字xcopy<br/>参数2：字符串/s<br/>参数3：字符串c:\\<br/>参数4: 字符串d:\\e<br/>请编写一个参数解析程序，实现将命令行各个参数解析出来。<br/><br/>解析规则：<br/>1.参数分隔符为空格<br/>2.对于用""包含起来的参数，如果中间有空格，不能解析为多个参数。比如在命令行输入xcopy /s "C:\\program files" "d:\"时，参数仍然是4个，第3个参数应该是字符串C:\\program files，而不是C:\\program，注意输出参数时，需要将""去掉，引号不存在嵌套情况。<br/>3.参数不定长<br/>4.输入由用例保证，不会出现不符合要求的输入<br/>数据范围：字符串长度：<br/>1≤s≤1000 <br/>进阶：时间复杂度：<br/>O(n)\<br/>O(n) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>输入一行字符串，可以有空格<br/>输出描述：<br/>输出参数个数，分解后的参数，每个参数都独占一行<br/><span class="example">示例1</span><br/>输入：<br/>xcopy /s c:\\ d:\\e<br/>输出：<br/>4<br/>xcopy<br/>/s<br/>c:\\<br/>d:\\e</p>
<button onclick='show(event)'>显示代码</button>
<pre>
al = input().split(" ")


args = []

for a in al:
    if len(args) == 0:
        args.append(a)
    elif args[-1][0] == '"' and args[-1][-1] != '"':
        args[-1] += " " + a
    else:
        args.append(a)

print(len(args))
for arg in args:
    print(arg.replace('"', ''))
</pre>
<hr/>
<h1>HJ75 公共子串计算</h1>
<p><span class="desc">描述</span><br/>给定两个只包含小写字母的字符串，计算两个字符串的最大公共子串的长度。<br/>注：子串的定义指一个字符串删掉其部分前缀和后缀（也可以不删）后形成的字符串。<br/>数据范围：字符串长度：<br/>1≤s≤150 <br/>进阶：时间复杂度：<br/>O(n^3)\<br/>O(n<br/>3<br/>) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>输入两个只包含小写字母的字符串<br/>输出描述：<br/>输出一个整数，代表最大公共子串的长度<br/><span class="example">示例1</span><br/>输入：<br/>asdfas<br/>werasdfaswer<br/>输出：<br/>6</p>
<button onclick='show(event)'>显示代码</button>
<pre>
a = input()
b = input()

if len(a) > len(b):
    a, b = b, a

ml = 0
for i in range(len(a)):
    for j in range(i+1, len(a)+1):
        if b.count(a[i:j]) > 0:
            ml = max(ml, j - i)
print(ml)
</pre>
<hr/>
<h1>HJ76 尼科彻斯定理</h1>
<p><span class="desc">描述</span><br/>验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。<br/>例如：<br/>1^3=1<br/>2^3=3+5<br/>3^3=7+9+11<br/>4^3=13+15+17+19<br/>输入一个正整数m（m≤100），将m的立方写成m个连续奇数之和的形式输出。<br/>数据范围：<br/>1≤m≤100 <br/>进阶：时间复杂度：<br/>O(m)\<br/>O(m) ，空间复杂度：<br/>O(1)\<br/>O(1) <br/><br/>输入描述：<br/>输入一个int整数<br/>输出描述：<br/>输出分解后的string<br/><span class="example">示例1</span><br/>输入：<br/>6<br/>输出：<br/>31+33+35+37+39+41</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())


avg = n * n

odds = []
inc = 1
if n % 2 != 0:
    inc += 1
    odds.append(avg)
    n -= 1
n //= 2
for i in range(n):
    odds.append(avg-inc)
    odds.append(avg+inc)
    inc += 2
print("+".join(map(str, sorted(odds))))
</pre>
<hr/>
<h1>HJ77 火车进站</h1>
<p><span class="desc">描述</span><br/>给定一个正整数N代表火车数量，0<N<10，接下来输入火车入站的序列，一共N辆火车，每辆火车以数字1-9编号，火车站只有一个方向进出，同时停靠在火车站的列车中，只有后进站的出站了，先进站的才能出站。<br/>要求输出所有火车出站的方案，以字典序排序输出。<br/>数据范围：<br/>1≤n≤10 <br/>进阶：时间复杂度：<br/>O(n!)\<br/>O(n!) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>第一行输入一个正整数N（0 < N <= 10），第二行包括N个正整数，范围为1到10。<br/>输出描述：<br/>输出以字典序从小到大排序的火车出站序列号，每个编号以空格隔开，每个输出序列换行，具体见sample。<br/><span class="example">示例1</span><br/>输入：<br/>3<br/>1 2 3<br/>输出：<br/>1 2 3<br/>1 3 2<br/>2 1 3<br/>2 3 1<br/>3 2 1<br/>说明：<br/>第一种方案：1进、1出、2进、2出、3进、3出<br/>第二种方案：1进、1出、2进、3进、3出、2出<br/>第三种方案：1进、2进、2出、1出、3进、3出<br/>第四种方案：1进、2进、2出、3进、3出、1出<br/>第五种方案：1进、2进、3进、3出、2出、1出<br/>请注意，[3,1,2]这个序列是不可能实现的。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())
nbs = list(map(int, input().split()))[::-1]

out = []
def scheme(queue, stack, output):
    if len(queue) == 0 and len(stack) == 0:
        out.append(output)
        return
    if len(stack) > 0:
        scheme(queue, stack[:-1], output + [stack[-1]])
    if len(queue) > 0:
        scheme(queue[:-1], stack + [queue[-1]], output)

scheme(nbs, [], [])
out.sort()
for r in out:
    print(" ".join(map(str, r)))
</pre>
<hr/>
<h1>HJ80 整型数组合并</h1>
<p><span class="desc">描述</span><br/>题目标题：<br/>将两个整型数组按照升序合并，并且过滤掉重复数组元素。<br/>输出时相邻两数之间没有空格。<br/><br/><br/><br/>输入描述：<br/>输入说明，按下列顺序输入：<br/>1 输入第一个数组的个数<br/>2 输入第一个数组的数值<br/>3 输入第二个数组的个数<br/>4 输入第二个数组的数值<br/>输出描述：<br/>输出合并之后的数组<br/><span class="example">示例1</span><br/>输入：<br/>3<br/>1 2 5<br/>4<br/>-1 0 3 2<br/>输出：<br/>-101235</p>
<button onclick='show(event)'>显示代码</button>
<pre>
m = input()
l1 = list(map(int, input().strip().split()))
n = input()
l2 = list(map(int, input().strip().split()))

l1.sort()
l2.sort()

rst = []
i, j = 0, 0
while i < len(l1) and j < len(l2):
    if l1[i] <= l2[j]:
        if len(rst) == 0 or l1[i] > rst[-1]:
            rst.append(l1[i])
        i += 1
    else:
        if len(rst) == 0 or l2[j] > rst[-1]:
            rst.append(l2[j])
        j += 1

while i < len(l1):
    if len(rst) == 0 or l1[i] > rst[-1]:
        rst.append(l1[i])
    i += 1

while j < len(l2):
    if len(rst) == 0 or l2[j] > rst[-1]:
        rst.append(l2[j])
    j += 1
    
print("".join(map(str, rst)))
</pre>
<hr/>
<h1>HJ81 字符串字符匹配</h1>
<p><span class="desc">描述</span><br/>判断短字符串S中的所有字符是否在长字符串T中全部出现。<br/>请注意本题有多组样例输入。<br/>数据范围:<br/>1\le len(S),len(T)\le200\<br/>1≤len(S),len(T)≤200 <br/>进阶：时间复杂度：<br/>O(n)\<br/>O(n) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>输入两个字符串。第一个为短字符串，第二个为长字符串。两个字符串均由小写字母组成。<br/>输出描述：<br/>如果短字符串的所有字符均在长字符串中出现过，则输出字符串"true"。否则输出字符串"false"。<br/><span class="example">示例1</span><br/>输入：<br/>bc<br/>abc<br/>输出：<br/>true<br/>说明：<br/>其中abc含有bc，输出"true"</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


strs = sys.stdin.read().strip().split("\n")
while strs:
    s = strs.pop(0).strip()
    t = strs.pop(0).strip()
    ss = set(s)
    ts = set(t)
    for c in ss:
        if c not in t:
            print("false")
            break
    else:
        print("true")
</pre>
<hr/>
<h1>HJ82 将真分数分解为埃及分数</h1>
<p><span class="desc">描述</span><br/>分子为1的分数称为埃及分数。现输入一个真分数(分子比分母小的分数，叫做真分数)，请将该分数分解为埃及分数。如：8/11 = 1/2+1/5+1/55+1/110。<br/>注：真分数指分子小于分母的分数，分子和分母有可能gcd不为1！<br/>如有多个解，请输出任意一个。<br/><br/><br/>输入描述：<br/>输入一个真分数，String型<br/>输出描述：<br/>输出分解后的string<br/><span class="example">示例1</span><br/>输入：<br/>8/11<br/>2/4<br/>输出：<br/>1/2+1/5+1/55+1/110<br/>1/3+1/6<br/>说明：<br/>第二个样例直接输出1/2也是可以的</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


def egypt(a, b):
    a *= 10
    b *= 10
    rst = []
    while a:
        for i in range(a, 0, -1):
            if b % i == 0:
                rst.append(b // i)
                a -= i
                break
    return rst


for line in sys.stdin:
    a, b = list(map(int, line.split("/")))
    print("+".join(map(lambda n: "1/{}".format(n), sorted(egypt(a, b)))))
</pre>
<hr/>
<h1>HJ83 二维数组操作</h1>
<p><span class="desc">描述</span><br/>有一个<br/>m∗n 大小的数据表，你会依次进行以下5种操作：<br/>1.输入<br/>m 和<br/>n ，初始化<br/>m∗n 大小的表格。<br/>2.输入<br/>x<br/>1<br/>、<br/>y<br/>1<br/>、<br/>x<br/>2<br/>、<br/>y<br/>2<br/>，交换坐标在<br/>((x_1,y_1)<br/>(x<br/>1<br/>,y<br/>1<br/>)和<br/>((x_2,y_2)<br/>(x<br/>2<br/>,y<br/>2<br/>)的两个数。<br/>3.输入<br/>x ，在第<br/>x 行上方添加一行。<br/>4.输入<br/>y ，在第<br/>y 列左边添加一列。<br/>5.输入<br/>x 、<br/>y ，查找坐标为<br/>((x,y)\<br/>(x,y) 的单元格的值。<br/>请编写程序，判断对表格的各种操作是否合法。<br/>详细要求:<br/>1.数据表的最大规格为9行*9列，对表格进行操作时遇到超出规格应该返回错误。<br/>2.对于插入操作，如果插入后行数或列数超过9了则应返回错误。如果插入成功了则将数据表恢复至初始化的<br/>m∗n 大小，多出的数据则应舍弃。<br/>3.所有输入坐标操作，对<br/>m∗n 大小的表格，行号坐标只允许0~m-1，列号坐标只允许0~n-1。超出范围应该返回错误。<br/>本题含有多组样例输入！行列从0开始标号<br/>数据范围：数据组数：<br/>1≤t≤5 <br/>进阶：时间复杂度：<br/>O(1)\<br/>O(1) ，空间复杂度：<br/>O(1)\<br/>O(1) <br/>输入描述：<br/>输入数据按下列顺序输入：<br/>1 表格的行列值<br/>2 要交换的两个单元格的行列值<br/>3 输入要插入的行的数值<br/>4 输入要插入的列的数值<br/>5 输入要查询的单元格的坐标<br/>输出描述：<br/>输出按下列顺序输出：<br/>1 初始化表格是否成功，若成功则返回0， 否则返回-1<br/>2 输出交换单元格是否成功<br/>3 输出插入行是否成功<br/>4 输出插入列是否成功<br/>5 输出查询单元格数据是否成功<br/><span class="example">示例1</span><br/>输入：<br/>4 9<br/>5 1 2 6<br/>0<br/>8<br/>2 3<br/>4 7<br/>4 2 3 2<br/>3<br/>3<br/>4 7<br/>输出：<br/>0<br/>-1<br/>0<br/>-1<br/>0<br/>0<br/>-1<br/>0<br/>0<br/>-1<br/>说明：<br/>本组样例共有2组样例输入。<br/>第一组样例：<br/>1.初始化数据表为4行9列，成功<br/>2.交换第5行1列和第2行6列的数据，失败。因为行的范围应该是(0,3)，不存在第5行。<br/>3.在第0行上方添加一行，成功。<br/>4.在第8列左边添加一列，失败。因为列的总数已经达到了9的上限。<br/>5.查询第2行第3列的值，成功。<br/>第二组样例：<br/>1.初始化数据表为4行7列，成功<br/>2.交换第4行2列和第3行2列的数据，失败。因为行的范围应该是(0,3)，不存在第4行。<br/>3.在第3行上方添加一行，成功。<br/>4.在第3列左边添加一列，成功。<br/>5.查询第4行7列的值，失败。因为虽然添加了一行一列，但数据表会在添加后恢复成4行7列的形态，所以行的区间仍然在[0,3]，列的区间仍然在[0,6]，无法查询到(4,7)坐标。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


data = sys.stdin.read().strip().split("\n")
while data:
    m, n = list(map(int, data.pop(0).strip().split()))
    x1, y1, x2, y2 = list(map(int, data.pop(0).strip().split()))
    x = int(data.pop(0))
    y = int(data.pop(0))
    sx, sy = list(map(int, data.pop(0).strip().split()))
    if 0 < m <= 9 and 0 < n <= 9:
        print(0)
    else:
        print(-1)
        
    if 0 <= x1 < m and 0 <= x2 < m and 0 <= y1 < n and 0 <= y2 < n:
        print(0)
    else:
        print(-1)
        
    if 0 <= x < m and m + 1 <= 9:
        print(0)
    else:
        print(-1)
        
    if 0 <= y < n and n + 1 <= 9:
        print(0)
    else:
        print(-1)
    
    if 0 <= sx < m and 0 <= sy < n:
        print(0)
    else:
        print(-1)
</pre>
<hr/>
<h1>HJ84 统计大写字母个数</h1>
<p><span class="desc">描述</span><br/>找出给定字符串中大写字符(即'A'-'Z')的个数。<br/>数据范围：字符串长度：<br/>1≤∣s∣≤250 <br/>字符串中可能包含空格或其他字符<br/>进阶：时间复杂度：<br/>O(n)\<br/>O(n) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>对于每组样例，输入一行，代表待统计的字符串<br/>输出描述：<br/>输出一个整数，代表字符串中大写字母的个数<br/><span class="example">示例1</span><br/>输入：<br/>A 1 0 1 1150175017(&^%&$vabovbaoadd 123#$%#%#O<br/>输出：<br/>2</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


cnt = 0
for c in sys.stdin.read().strip():
    if 'A' <= c <= 'Z':
        cnt += 1
print(cnt)
</pre>
<hr/>
<h1>HJ85 最长回文子串</h1>
<p><span class="desc">描述</span><br/>给定一个仅包含小写字母的字符串，求它的最长回文子串的长度。<br/>所谓回文串，指左右对称的字符串。<br/>所谓子串，指一个字符串删掉其部分前缀和后缀（也可以不删）的字符串<br/>数据范围：字符串长度<br/>1≤s≤350 <br/>进阶：时间复杂度：<br/>O(n)\<br/>O(n) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/>输入描述：<br/>输入一个仅包含小写字母的字符串<br/>输出描述：<br/>返回最长回文子串的长度<br/><span class="example">示例1</span><br/>输入：<br/>cdabbacc<br/>输出：<br/>4<br/>说明：<br/>abba为最长的回文子串</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


def sym(s):
    b, e = 0, len(s)-1
    while b < e:
        if s[b] != s[e]:
            return False
        b += 1
        e -= 1
    return True

ml = 1
s = input()
for i in range(len(s)):
    for j in range(i+1, len(s)+1):
        if sym(s[i:j]):
            ml = max(ml, j-i)
print(ml)
</pre>
<hr/>
<h1>HJ86 求最大连续bit数</h1>
<p><span class="desc">描述</span><br/>求一个int类型数字对应的二进制数字中1的最大连续数，例如3的二进制为00000011，最大连续2个1<br/>数据范围：数据组数：<br/>1≤t≤5 ，<br/>1≤n≤500000 <br/>进阶：时间复杂度：<br/>O(logn)\<br/>O(logn) ，空间复杂度：<br/>O(1)\<br/>O(1) <br/>输入描述：<br/>输入一个int类型数字<br/>输出描述：<br/>输出转成二进制之后连续1的个数<br/><span class="example">示例1</span><br/>输入：<br/>200<br/>输出：<br/>2<br/>说明：<br/>200的二进制表示是11001000，最多有2个连续的1。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())

print(max(map(len, bin(n)[2:].split("0"))))
</pre>
<hr/>
<h1>HJ87 密码强度等级</h1>
<p><span class="desc">描述</span><br/>密码按如下规则进行计分，并根据不同的得分为密码进行安全等级划分。<br/><br/>一、密码长度:<br/>5 分: 小于等于4 个字符<br/>10 分: 5 到7 字符<br/>25 分: 大于等于8 个字符<br/><br/>二、字母:<br/>0 分: 没有字母<br/>10 分: 密码里的字母全都是小（大）写字母<br/>20 分: 密码里的字母符合”大小写混合“<br/><br/>三、数字:<br/>0 分: 没有数字<br/>10 分: 1 个数字<br/>20 分: 大于1 个数字<br/><br/>四、符号:<br/>0 分: 没有符号<br/>10 分: 1 个符号<br/>25 分: 大于1 个符号<br/><br/>五、奖励（只能选符合最多的那一种奖励）:<br/>2 分: 字母和数字<br/>3 分: 字母、数字和符号<br/>5 分: 大小写字母、数字和符号<br/><br/>最后的评分标准:<br/>>= 90: 非常安全<br/>>= 80: 安全（Secure）<br/>>= 70: 非常强<br/>>= 60: 强（Strong）<br/>>= 50: 一般（Average）<br/>>= 25: 弱（Weak）<br/>>= 0:  非常弱（Very_Weak）<br/><br/>对应输出为：<br/><br/>VERY_SECURE<br/>SECURE<br/>VERY_STRONG<br/>STRONG<br/>AVERAGE<br/>WEAK<br/>VERY_WEAK<br/><br/>请根据输入的密码字符串，进行安全评定。<br/><br/>注：<br/>字母：a-z, A-Z<br/>数字：0-9<br/>符号包含如下： (ASCII码表可以在UltraEdit的菜单view->ASCII Table查看)<br/>!"#$%&'()*+,-./     (ASCII码：0x21~0x2F)<br/>:;<=>?@             (ASCII码：0x3A~0x40)<br/>[\]^_`              (ASCII码：0x5B~0x60)<br/>{|}~                (ASCII码：0x7B~0x7E)<br/><br/>提示:<br/>1 <= 字符串的长度<= 300<br/>输入描述：<br/>输入一个string的密码<br/>输出描述：<br/>输出密码等级<br/><span class="example">示例1</span><br/>输入：<br/>38$@NoNoN<br/>输出：<br/>VERY_SECURE<br/>说明：<br/>样例的密码长度大于等于8个字符，得25分；大小写字母都有所以得20分；有两个数字，所以得20分；包含大于1符号，所以得25分；由于该密码包含大小写字母、数字和符号，所以奖励部分得5分，经统计得该密码的密码强度为25+20+20+25+5=95分。<br/>         <br/><span class="example">示例2</span><br/>输入：<br/>Jl)M:+<br/>输出：<br/>AVERAGE<br/>说明：<br/>示例2的密码强度为10+20+0+25+0=55分。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
punctuation = '''!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'''

s = input().strip()

credit = 0

sl = len(s)
if sl <= 4:
    credit += 5
elif sl <= 7:
    credit += 10
else:
    credit += 25

ls, us, ns, ps = [], [], [], []

for c in s:
    if 'a' <= c <= 'z':
        ls.append(c)
    elif 'A' <= c <= 'Z':
        us.append(c)
    elif '0' <= c <= '9':
        ns.append(c)
    else:
        ps.append(c)

if len(ls) + len(us) == 0:
    credit += 0
elif len(ls) == 0 or len(us) == 0:
    credit += 10
else:
    credit += 20

if len(ns) == 0:
    credit += 0
elif len(ns) == 1:
    credit += 10
else:
    credit += 20

if len(ps) == 0:
    credit += 0
elif len(ps) == 1:
    credit += 10
else:
    credit += 25

if len(ns) > 0 and len(ls) + len(us) > 0:
    if len(ps) > 0:
        if len(ls) > 0 and len(us) > 0:
            credit += 5
        else:
            credit += 3
    else:
        credit += 2

if credit >= 90:
    rank = "VERY_SECURE"
elif credit >= 80:
    rank = "SECURE"
elif credit >= 70:
    rank = "VERY_STRONG"
elif credit >= 60:
    rank = "STRONG"
elif credit >= 50:
    rank = "AVERAGE"
elif credit >= 25:
    rank = "WEAK"
else:
    rank = "VERY_WEAK"
    
print(rank)
</pre>
<hr/>
<h1>HJ88 扑克牌大小</h1>
<p><span class="desc">描述</span><br/>扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A、2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）：<br/>3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER<br/>输入两手牌，两手牌之间用"-"连接，每手牌的每张牌以空格分隔，"-"两边没有空格，如：4 4 4 4-joker JOKER。<br/>请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR。<br/>基本规则：<br/>（1）输入每手牌可能是个子、对子、顺子（连续5张）、三个、炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列；<br/>（2）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子）；<br/>（3）大小规则跟大家平时了解的常见规则相同，个子、对子、三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌；<br/>（4）输入的两手牌不会出现相等的情况。<br/>数据范围：字符串长度：<br/>3≤s≤10 <br/><br/><br/>输入描述：<br/>输入两手牌，两手牌之间用"-"连接，每手牌的每张牌以空格分隔，"-"两边没有空格，如 4 4 4 4-joker JOKER。<br/>输出描述：<br/>输出两手牌中较大的那手，不含连接符，扑克牌顺序不变，仍以空格隔开；如果不存在比较关系则输出ERROR。<br/><span class="example">示例1</span><br/>输入：<br/>4 4 4 4-joker JOKER<br/>输出：<br/>joker JOKER</p>
<button onclick='show(event)'>显示代码</button>
<pre>
pokes = "3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER"
pm = {v: i for i, v in enumerate(pokes.split())}


a, b = [s.split() for s in input().split("-")]
av = [pm[e] for e in a]
bv = [pm[e] for e in b]


def getS(l):
    if len(l) == 2 and pm["joker"] in l:
        return [7, 0]
    if len(l) == 4:
        return [6, l[0]]
    return [len(l), l[0]]


sa, sb = getS(av), getS(bv)
if max(sa[0], sb[0]) < 6:
    if sa[0] == sb[0]:
        print(" ".join(a if sa[1] > sb[1] else b))
    else:
        print("ERROR")
else:
    print(" ".join(a if sa > sb else b))
</pre>
<hr/>
<h1>HJ89 24点运算</h1>
<p><span class="desc">描述</span><br/>计算24点是一种扑克牌益智游戏，随机抽出4张扑克牌，通过加(+)，减(-)，乘(*), 除(/)四种运算法则计算得到整数24，本问题中，扑克牌通过如下字符或者字符串表示，其中，小写joker表示小王，大写JOKER表示大王：<br/>3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER<br/>本程序要求实现：输入4张牌，输出一个算式，算式的结果为24点。<br/>详细说明：<br/>1.运算只考虑加减乘除运算，没有阶乘等特殊运算符号，没有括号，友情提醒，整数除法要当心，是属于整除，比如2/3=0，3/2=1；<br/>2.牌面2~10对应的权值为2~10, J、Q、K、A权值分别为为11、12、13、1；<br/>3.输入4张牌为字符串形式，以一个空格隔开，首尾无空格；如果输入的4张牌中包含大小王，则输出字符串“ERROR”，表示无法运算；<br/>4.输出的算式格式为4张牌通过+-*/四个运算符相连，中间无空格，4张牌出现顺序任意，只要结果正确；<br/>5.输出算式的运算顺序从左至右，不包含括号，如1+2+3*4的结果为24，2 A 9 A不能变为(2+1)*(9-1)=24<br/>6.如果存在多种算式都能计算得出24，只需输出一种即可，如果无法得出24，则输出“NONE”表示无解。<br/>7.因为都是扑克牌，不存在单个牌为0的情况，且没有括号运算，除数(即分母)的数字不可能为0<br/><br/>数据范围：一行由4张牌组成的字符串<br/>输入描述：<br/>输入4张牌为字符串形式，以一个空格隔开，首尾无空格；<br/>输出描述：<br/>输出怎么运算得到24，如果无法得出24，则输出“NONE”表示无解，如果输入的4张牌中包含大小王，则输出字符串“ERROR”，表示无法运算；<br/><span class="example">示例1</span><br/>输入：<br/>A A A A<br/>输出：<br/>NONE<br/>说明：<br/>不能实现           <br/><span class="example">示例2</span><br/>输入：<br/>4 2 K A<br/>输出：<br/>K-A*4/2<br/>说明：<br/> A+K*2-4也是一种答案，输出任意一种即可           <br/><span class="example">示例3</span><br/>输入：<br/>B 5 joker 4<br/>输出：<br/>ERROR<br/>说明：<br/> 存在joker，输出ERROR          <br/><span class="example">示例4</span><br/>输入：<br/>K Q 6 K<br/>输出：<br/>NONE<br/>说明：<br/>按一般的计算规则来看，K+K-(Q/6)=24 或 K-((Q/6)-K)=24，但是因为这个题目的运算不许有括号，所以去掉括号后变为 K+K-Q/6=26-Q/6=14/6=2 或 K-Q/6-K=1/6-K=0-K=-13，其它情况也不能运算出24点，故不存在，输出NONE</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


pks = input().upper().split()

if "JOKER" in pks:
    print("ERROR")
    sys.exit(0)

pm = {v: (i+1) for i,v in enumerate("A 2 3 4 5 6 7 8 9 10 J Q K".split())}
mp = {pm[k]: k for k in pm}
nums = [pm[p] for p in pks]


def calc(rem, used, start):
    if len(rem) == 0:
        return used if 24 == start else None
    for i in range(len(rem)):
        nr = rem[:i] + rem[i+1:]
        e = rem[i]
        if start is None:
            rst = calc(nr, used + [e], e)
            if rst:
                return rst
        else:
            rst = calc(nr, used + ['+', e], start + e)
            if rst:
                return rst
            rst = calc(nr, used + ['-', e], start - e)
            if rst:
                return rst
            rst = calc(nr, used + ['*', e], start * e)
            if rst:
                return rst
            rst = calc(nr, used + ['/', e], start // e)
            if rst:
                return rst
    return None


rst = calc(nums, [], None)
# print(rst)
print("NONE" if rst is None else "".join([mp.get(e, e) for e in rst]))
</pre>
<hr/>
<h1>HJ90 合法IP</h1>
<p><span class="desc">描述</span><br/>IPV4地址可以用一个32位无符号整数来表示，一般用点分方式来显示，点将IP地址分成4个部分，每个部分为8位，表示成一个无符号整数（因此正号不需要出现），如10.137.17.1，是我们非常熟悉的IP地址，一个IP地址串中没有空格出现（因为要表示成一个32数字）。<br/>现在需要你用程序来判断IP是否合法。<br/><br/>数据范围：数据组数：<br/>1≤t≤18 <br/>进阶：时间复杂度：<br/>O(n)\<br/>O(n) ，空间复杂度：<br/>O(n)\<br/>O(n) <br/><br/>输入描述：<br/>输入一个ip地址，保证不包含空格<br/>输出描述：<br/>返回判断的结果YES or NO<br/><span class="example">示例1</span><br/>输入：<br/>255.255.255.1000<br/>输出：<br/>NO</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


s = input()
parts = s.split(".")
if len(parts) != 4:
    print("NO")
    sys.exit(0)

for s in parts:
    try:
        n = int(s)
        if not 0 <= n < 256 or (n > 0 and s[0] in '+0'):
            print("NO")
            sys.exit(0)
    except Exception as _:
        print("NO")
        sys.exit(0)

print("YES")
</pre>
<hr/>
<h1>HJ91 走方格的方案数</h1>
<p><span class="desc">描述</span><br/>请计算n*m的棋盘格子（n为横向的格子数，m为竖向的格子数）从棋盘左上角出发沿着边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。<br/><br/>注：沿棋盘格之间的边缘线行走<br/><br/>数据范围：<br/>1≤n,m≤8 <br/><br/><br/>输入描述：<br/>输入两个正整数n和m，用空格隔开。(1≤n,m≤8)<br/>输出描述：<br/>输出一行结果<br/><span class="example">示例1</span><br/>输入：<br/>2 2<br/>输出：<br/>6</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n, m = list(map(int, input().strip().split()))

ts = [[0, 0]]
routes = 0
while True:
    nts = []
    while ts:
        pos = ts.pop()
        if pos[0] + 1 <= n:
            p = [pos[0]+1, pos[1]]
            if p == [n, m]:
                routes += 1
            else:
                nts.append([pos[0]+1, pos[1]])
        if pos[1] + 1 <= m:
            p = [pos[0], pos[1]+1]
            if p == [n, m]:
                routes += 1
            else:
                nts.append([pos[0], pos[1]+1])
    if not nts:
        break
    ts = nts
print(routes)
</pre>
<hr/>
<h1>HJ92 在字符串中找出连续最长的数字串</h1>
<p><span class="desc">描述</span><br/>输入一个字符串，返回其最长的数字子串，以及其长度。若有多个最长的数字子串，则将它们全部输出（按原字符串的相对位置）<br/>本题含有多组样例输入。<br/><br/>数据范围：字符串长度<br/>1≤n≤200  ， 保证每组输入都至少含有一个数字<br/>输入描述：<br/>输入一个字符串。1<=len(字符串)<=200<br/>输出描述：<br/>输出字符串中最长的数字字符串和它的长度，中间用逗号间隔。如果有相同长度的串，则要一块儿输出（中间不要输出空格）。<br/><span class="example">示例1</span><br/>输入：<br/>abcd12345ed125ss123058789<br/>a8a72a6a5yy98y65ee1r2<br/>输出：<br/>123058789,9<br/>729865,2<br/>说明：<br/>样例一最长的数字子串为123058789，长度为9<br/>样例二最长的数字子串有72,98,65，长度都为2</p>
<button onclick='show(event)'>显示代码</button>
<pre>
def longest(s):
    ns = []
    res = []
    rst = []
    for c in s:
        if '0' <= c <= '9':
            ns.append(c)
        else:
            ns.append(",")
    
    for i, ss in enumerate(''.join(ns).split(',')):
        if ss:
            res.append((-len(ss), i, ss))
    res.sort()
    for p in res:
        if p[0] > res[0][0]:
            break
        rst.append(p[2])
    return rst


while True:
    try:
        s = input()
        r = longest(s)
        print("{},{}".format("".join(r), len(r[0])))
    except Exception as _:
        break
</pre>
<hr/>
<h1>HJ93 数组分组</h1>
<p><span class="desc">描述</span><br/>输入int型数组，询问该数组能否分成两组，使得两组中各元素加起来的和相等，并且，所有5的倍数必须在其中一个组中，所有3的倍数在另一个组中（不包括5的倍数），不是5的倍数也不是3的倍数能放在任意一组，可以将数组分为空数组，能满足以上条件，输出true；不满足时输出false。<br/><br/>数据范围：每个数组大小满足<br/>1≤n≤50  ，输入的数据大小满足<br/>∣val∣≤500 <br/>输入描述：<br/>第一行是数据个数，第二行是输入的数据<br/>输出描述：<br/>返回true或者false<br/><span class="example">示例1</span><br/>输入：<br/>4<br/>1 5 -5 1<br/>输出：<br/>true<br/>说明：<br/>第一组：5 -5 1<br/>第二组：1   <br/><span class="example">示例2</span><br/>输入：<br/>3<br/>3 5 8<br/>输出：<br/>false<br/>说明：<br/>由于3和5不能放在同一组，所以不存在一种分法。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
_ = input()
nums = list(map(int, input().split()))


g5, g3, og = [], [], []
for n in nums:
    if n % 5 == 0:
        g5.append(n)
    elif n % 3 == 0:
        g3.append(n)
    else:
        og.append(n)


def classify(rem, g5, g3):
    if len(rem) == 0:
        return sum(g5) == sum(g3)
    return classify(rem[1:], g5 + [rem[0]], g3) or classify(rem[1:], g5, g3 + [rem[0]])


print("true" if classify(og, g5, g3) else "false")
</pre>
<hr/>
<h1>HJ94 记票统计</h1>
<p><span class="desc">描述</span><br/>请实现一个计票统计系统。你会收到很多投票，其中有合法的也有不合法的，请统计每个候选人得票的数量以及不合法的票数。<br/>（注：不合法的投票指的是投票的名字不存在n个候选人的名字中！！）<br/><br/>数据范围：每组输入中候选人数量满足<br/>1≤n≤100  ，总票数量满足<br/>1≤n≤100 <br/>输入描述：<br/>第一行输入候选人的人数n，第二行输入n个候选人的名字（均为大写字母的字符串），第三行输入投票人的人数，第四行输入投票。<br/>输出描述：<br/>按照输入的顺序，每行输出候选人的名字和得票数量（以" : "隔开，注：英文冒号左右两边都有一个空格！），最后一行输出不合法的票数，格式为"Invalid : "+不合法的票数。<br/><span class="example">示例1</span><br/>输入：<br/>4<br/>A B C D<br/>8<br/>A D E CF A GG A B<br/>输出：<br/>A : 3<br/>B : 1<br/>C : 0<br/>D : 1<br/>Invalid : 3<br/>说明：<br/>E CF GG三张票是无效的，所以Invalid的数量是3.</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys

cn = int(input())
candl = input().strip().split()
cands = set(candl)
pn = int(input())
polls = input().strip().split()

invalid = 0
stat = {}
for p in polls:
    if p not in cands:
        invalid += 1
    stat[p] = stat.get(p, 0) + 1
for k in candl:
    print("{} : {}".format(k, stat.get(k, 0)))
print("Invalid : {}".format(invalid))
</pre>
<hr/>
<h1>HJ95 人民币转换</h1>
<p><span class="desc">描述</span><br/>考试题目和要点：<br/>1、中文大写金额数字前应标明“人民币”字样。中文大写金额数字应用壹、贰、叁、肆、伍、陆、柒、捌、玖、拾、佰、仟、万、亿、元、角、分、零、整等字样填写。<br/>2、中文大写金额数字到“元”为止的，在“元”之后，应写“整字，如532.00应写成“人民币伍佰叁拾贰元整”。在”角“和”分“后面不写”整字。<br/>3、阿拉伯数字中间有“0”时，中文大写要写“零”字，阿拉伯数字中间连续有几个“0”时，中文大写金额中间只写一个“零”字，如6007.14，应写成“人民币陆仟零柒元壹角肆分“。<br/>4、10应写作“拾”，100应写作“壹佰”。例如，1010.00应写作“人民币壹仟零拾元整”，110.00应写作“人民币壹佰拾元整”<br/>5、十万以上的数字接千不用加“零”，例如，30105000.00应写作“人民币叁仟零拾万伍仟元整”<br/><br/>输入描述：<br/>输入一个double数<br/>输出描述：<br/>输出人民币格式<br/><span class="example">示例1</span><br/>输入：<br/>151121.15<br/>输出：<br/>人民币拾伍万壹仟壹佰贰拾壹元壹角伍分<br/><span class="example">示例2</span><br/>输入：<br/>1010.00<br/>输出：<br/>人民币壹仟零拾元整</p>
<button onclick='show(event)'>显示代码</button>
<pre>
v = input()


rst = "人民币"
numbers = "零、壹、贰、叁、肆、伍、陆、柒、捌、玖".split("、")
"""
拾、佰、仟、万、亿、元、角、分、整
"""

def get_number(n):
    rst = ""
    if n[0] == "0":
        rst += "零"
    n.lstrip("0")
    nb = int(n)
    uts = [(1000, "仟"), (100, "佰"), (10, "拾"), (1, "")]
    for u in uts:
        if nb >= u[0]:
            rst += numbers[nb // u[0]] + u[1]
        else:
            if rst and rst[-1] != "零":
                rst += "零"
        nb %= u[0]
    return rst.rstrip("零").replace("壹拾", "拾")


def get_frac(fp):
    if "00" == fp:
        return "整"

    a = int(fp[0])
    b = int(fp[1])

    rst = ""
    if a > 0:
        rst += numbers[a] + "角"
    if b > 0:
        rst += numbers[b] + "分"
    return rst


n, f = v.split(".")
if int(n) > 0:
    units = ["", "万", "亿"]
    for i in range(len(units)-1, -1, -1):
        pn = n[(i+1)*(-4):i*(-4)] if i > 0 else n[-4:]
        if pn and int(pn) > 0:
            numb = get_number(pn)
            rst += numb + units[i]
    rst += "元"

rst += get_frac(f)
print(rst)
</pre>
<hr/>
<h1>HJ96 表示数字</h1>
<p><span class="desc">描述</span><br/>将一个字符中所有的整数前后加上符号“*”，其他字符保持不变。连续的数字视为一个整数。<br/><br/>数据范围：字符串长度满足<br/>1≤n≤100 <br/>输入描述：<br/>输入一个字符串<br/>输出描述：<br/>字符中所有出现的数字前后加上符号“*”，其他字符保持不变<br/><span class="example">示例1</span><br/>输入：<br/>Jkdi234klowe90a3<br/>输出：<br/>Jkdi*234*klowe*90*a*3*</p>
<button onclick='show(event)'>显示代码</button>
<pre>
s = input().strip()

ns = []
for c in s:
    if len(ns) == 0:
        if '0' <= c <= '9':
            ns.append('*')
        ns.append(c)
        continue
    if ((ns[-1] < '0' or ns[-1] > '9') and '0' <= c <= '9') or \
        ((c < '0' or c > '9') and '0' <= ns[-1] <= '9'):
        ns.append('*')
    ns.append(c)
if '0' <= ns[-1] <= '9':
    ns.append('*')
print(''.join(ns))
</pre>
<hr/>
<h1>HJ97 记负均正</h1>
<p><span class="desc">描述</span><br/>首先输入要输入的整数个数n，然后输入n个整数。输出为n个整数中负数的个数，和所有正整数的平均值，结果保留一位小数。<br/>0即不是正整数，也不是负数，不计入计算。如果没有正数，则平均值为0。<br/><br/>数据范围：<br/>1≤n ≤2000  ，输入的整数都满足<br/>∣val∣≤1000 <br/>输入描述：<br/>首先输入一个正整数n，<br/>然后输入n个整数。<br/>输出描述：<br/>输出负数的个数，和所有正整数的平均值。<br/><span class="example">示例1</span><br/>输入：<br/>11 <br/>1 2 3 4 5 6 7 8 9 0 -1<br/>输出：<br/>1 5.0<br/><span class="example">示例2</span><br/>输入：<br/>3<br/>0 0 0<br/>输出：<br/>0 0.0</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = input()
arr = map(int, input().strip().split())

ncnt = 0
pcnt = 0
psum = 0.0
for i in arr:
    if i < 0:
        ncnt += 1
    if i > 0:
        pcnt += 1
        psum += i
print("{} {:.1f}".format(ncnt, 0.0 if not pcnt else (psum / pcnt)))
</pre>
<hr/>
<h1>HJ98 自动售货系统</h1>
<p><span class="desc">描述</span><br/>1 总体说明<br/>考生需要模拟实现一个简单的自动售货系统，实现投币、购买商品、退币、查询库存商品及存钱盒信息的功能。<br/>系统初始化时自动售货机中商品为6种商品,商品的单价参见1.1规格说明，存钱盒内放置1元、2元、5元、10元钱币，商品数量和钱币张数通过初始化命令设置，参见2.1 系统初始化。<br/>1.1规格说明<br/>1. 商品:每种商品包含商品名称、单价、数量三种属性，其中商品名不重复。考生不能修改商品名称和单价，初始化命令设置商品数量。这些信息在考试框架中进行定义，考生在实现功能代码时可直接使用。<br/>商品 名称<br/>单价<br/>数量<br/>A1 2 X<br/>A2 3 X<br/>A3 4 X<br/>A4 5 X<br/>A5 8 X<br/>A6 6 X<br/>2. 存钱盒信息：钱币面额、张数两种属性。初始化命令设置各种面额钱币张数。这些信息在考试框架中进行定义，考生在实现功能代码时可直接使用。<br/>钱币面额<br/>张数<br/>10元<br/>X<br/>5元<br/>X<br/>2元 X<br/>1元 X<br/>3. 退币原则 ：<br/>1) 根据系统存钱盒内钱币的 信息 ，按钱币总张数最少的原则进行退币。<br/>2) 如果因零钱不足导致不能退币，则尽最大可能退币，以减少用户损失。<br/>例如：假设存钱盒内只有4张2元，无其它面额钱币。如果需要退币7元，系统因零钱不足无法退币，则继续尝试退币6元，最终系统成功退币3张2元,用户损失1元钱币。<br/>4. 投币操作说明：每次投币成功，投入的钱币面额累加到投币余额；同时，本次投入的钱币放入存钱盒中，存钱盒相应面额钱币增加。<br/>5. 投币余额：指当前自动售货机中用户剩余的可购买商品的钱币总额；例如：投入2元面额的钱币，投币余额增加2元；购买一件价格2元的商品，投币余额减少2元；<br/>6. 退币操作说明：退币操作需要遵守 退币原则 ；退币成功后，投币余额清零，同时扣除存钱盒相应的金额。<br/>7. 购买商品操作说明：一次仅允许购买一件商品；购买商品成功后，自动售货机中对应商品数量减1，投币余额扣除本次购买商品的价格。<br/>2 操作说明<br/>命令字与第一个参数间使用一个空格分隔，多条命令采用分号隔开。考试系统会对输入命令格式进行处理，考生不需要关注输入命令格式的合法性，只需要实现命令处理函数。<br/>2.1 系统初始化<br/>命令格式：<br/>r A1 数量 -A2 数量 -A3 数量 -A4 数量 -A5 数量 -A6 数量 1 元张数 -2 元张数 -5 元张数 -10 元张数<br/>参数名称<br/>参数说明<br/>类型<br/>取值范围<br/>A1数量<br/>商品A1数量<br/>整数<br/>[0,30]<br/>A2数量<br/>商品A2数量<br/>整数<br/>[0,30]<br/>A3数量<br/>商品A3数量<br/>整数<br/>[0,30]<br/>A4数量<br/>商品A4数量<br/>整数<br/>[0,30]<br/>A5数量<br/>商品A5数量<br/>整数<br/>[0,30]<br/>A6数量<br/>商品A6数量<br/>整数<br/>[0,30]<br/>1元张数<br/>面额1元钱币张数<br/>整数<br/>[0,30]<br/>2元张数<br/>面额2元钱币张数<br/>整数<br/>[0,30]<br/>5元张数<br/>面额5元钱币张数<br/>整数<br/>[0,30]<br/>10元张数<br/>面额10元钱币张数<br/>整数<br/>[0,30]<br/>商品和各种面额钱币取值范围只是作为初始化命令的限制，其它场景下不限制取值范围；考试框架已经实现取值范围的检查，考生不需要关注。<br/>功能说明：设置自动售货机中商品数量和存钱盒各种面额的钱币张数；<br/>约束说明：系统在任意阶段均可执行r初始化系统；考生不需要关注参数的合法性，不需要关注增加或缺少参数的场景；<br/>输出说明：输出操作成功提示（执行完r命令后系统会自动输出操作结果，考生不需要再次调用输出函数），例：<br/>命令 输出 含义<br/>r 6-5-4-3-2-1 4-3-2-1; S001:Initialization is successful 初始化成功<br/>2.2 投币<br/>命令格式：p 钱币面额<br/>功能说明：<br/>（1） 如果投入非1元、2元、5元、10元的钱币面额（钱币面额不考虑负数、字符等非正整数的情况），输出“E002:Denomination error”；<br/>（2） 如果存钱盒中1元和2元面额钱币总额小于本次投入的钱币面额，输出“E003:Change is not enough, pay fail”，但投入1元和2元面额钱币不受此限制。<br/>（3） 如果自动售货机中商品全部销售完毕，投币失败。输出“E005:All the goods sold out”；<br/>（4） 如果投币成功，输出“S002:Pay success,balance=X”；<br/>约束说明：<br/>（1） 系统在任意阶段都可以投币；<br/>（2） 一次投币只能投一张钱币；<br/>（3） 同等条件下，错误码的优先级：E002 > E003 > E005；<br/>输出说明：如果投币成功，输出“S002:Pay success,balance=X”。<br/>例：<br/>命令<br/>输出<br/>p 10;<br/>S002:Pay success,balance=10<br/>2.3 购买商品<br/>命令格式：b 商品名称<br/>功能说明：<br/>（1） 如果购买的商品不在商品列表中，输出“E006:Goods does not exist”；<br/>（2） 如果所购买的商品的数量为0，输出“E007:The goods sold out”；<br/>（3） 如果投币余额小于待购买商品价格，输出“E008:Lack of balance”；<br/>（4） 如果购买成功，输出“S003:Buy success,balance=X”；<br/>约束说明：<br/>（1） 一次购买操作仅能购买一件商品，可以多次购买；<br/>（2） 同等条件下，错误码的优先级：E006 > E007 > E008；<br/>输出说明：<br/>如果购买成功，输出“S003:Buy success,balance=X”。<br/>例:<br/>命令<br/>输出<br/>b A1;<br/>S003:Buy success,balance=8<br/>2.4 退币<br/>命令格式：c<br/>功能说明：<br/>（1） 如果投币余额等于0的情况下，输出“E009:Work failure”；<br/>（2） 如果投币余额大于0的情况下，按照 退币原则 进行“找零”，输出退币信息；<br/>约束说明：<br/>（1） 系统在任意阶段都可以退币；<br/>（2） 退币方式必须按照 退币原则 进行退币；<br/>输出说明：如果退币成功，按照 退币原则 输出退币信息。<br/>例，退5元钱币:<br/>命令<br/>输出<br/>c;<br/>1 yuan coin number=0<br/>2 yuan coin number=0<br/>5 yuan coin number=1<br/>10 yuan coin number=0<br/>2.5 查询<br/>命令格式：q 查询类别<br/>功能说明：<br/>（1） 查询自动售货机中商品信息，包含商品名称、单价、数量。 根据商品数量从大到小进行排序；商品数量相同时，按照商品名称的先后顺序进行排序 。<br/>例如：A1的商品名称先于A2的商品名称，A2的商品名称先于A3的商品名称。<br/>（2） 查询存钱盒信息，包含各种面额钱币的张数；<br/>（3） 查询类别如下表所示:<br/>查询类别<br/>查询内容<br/>0<br/>查询商品信息<br/>1 查询存钱盒信息<br/>如果“查询类别”参数错误，输出“E010:Parameter error”。“查询类别”参数错误时，不进行下面的处理；<br/>输出说明：<br/>“查询类别”为0时，输出自动售货机中所有商品信息（商品名称单价数量）例：<br/>命令<br/>输出<br/>q 0;<br/>A1 2 6<br/>A2 3 5<br/>A3 4 4<br/>A4 5 3<br/>A5 8 2<br/>A6 6 0<br/>“查询类别”为1时，输出存钱盒信息（各种面额钱币的张数），格式固定。例：<br/>命令<br/>输出<br/>q 1;<br/>1 yuan coin number=4<br/>2 yuan coin number=3<br/>5 yuan coin number=2<br/>10 yuan coin number=1<br/><br/>输入描述：<br/>依照说明中的命令码格式输入命令。<br/>输出描述：<br/>输出执行结果<br/><span class="example">示例1</span><br/>输入：<br/>r 22-18-21-21-7-20 3-23-10-6;c;q0;p 1;b A6;c;b A5;b A1;c;q1;p 5;<br/>输出：<br/>S001:Initialization is successful<br/>E009:Work failure<br/>E010:Parameter error<br/>S002:Pay success,balance=1<br/>E008:Lack of balance<br/>1 yuan coin number=1<br/>2 yuan coin number=0<br/>5 yuan coin number=0<br/>10 yuan coin number=0<br/>E008:Lack of balance<br/>E008:Lack of balance<br/>E009:Work failure<br/>E010:Parameter error<br/>S002:Pay success,balance=5</p>
<button onclick='show(event)'>显示代码</button>
<pre>
goods_value = {
    "A1": 2,
    "A2": 3,
    "A3": 4,
    "A4": 5,
    "A5": 8,
    "A6": 6
}


class shop:
    def __init__(self, goods_nums, money_nums):
        self.goods = {}
        for i in range(1, 7):
            name = "A{}".format(i)
            self.goods[name] = [goods_value[name], goods_nums[i-1]]
        self.money = []
        for p in zip([1, 2, 5, 10], money_nums):
            self.money.append(list(p))
        self.remain = 0
        print("S001:Initialization is successful")

    def put(self, n):
        if n not in [e[0] for e in self.money]:
            print("E002:Denomination error")
            return
        if n not in [1, 2] and self.money[0][1] + self.money[1][1] * 2 < n:
            print("E003:Change is not enough, pay fail")
            return
        if sum([self.goods[g][1] for g in self.goods]) == 0:
            print("E005:All the goods sold out")
            return
        for p in self.money:
            if p[0] == n:
                self.remain += n
                p[1] += 1
                print("S002:Pay success,balance={}".format(self.remain))
                return

    def buy(self, g):
        if g not in self.goods:
            print("E006:Goods does not exist")
            return
        if self.goods[g][1] == 0:
            print("E007:The goods sold out")
            return
        if self.remain < self.goods[g][0]:
            print("E008:Lack of balance")
            return
        self.remain -= self.goods[g][0]
        self.goods[g][1] -= 1
        print("S003:Buy success,balance={}".format(self.remain))

    def withdraw(self):
        if self.remain == 0:
            print("E009:Work failure")
            return
        wd = []
        for i in range(len(self.money)-1, -1, -1):
            m = self.money[i]
            cnt = min(self.remain // m[0], m[1])
            wd.append((m[0], cnt))
            self.remain -= m[0] * cnt
            m[1] -= cnt
        self.remain = 0
        for p in wd[::-1]:
            print("{} yuan coin number={}".format(p[0], p[1]))

    def query(self, c):
        if c not in ("0", "1"):
            print("E010:Parameter error")
            return

        if c == "0":
            gds = []
            for g in self.goods:
                gds.append((-self.goods[g][1], g, self.goods[g][0]))
            gds.sort()
            for gp in gds:
                print("{} {} {}".format(gp[1], gp[2], -gp[0]))
        else:
            for mp in self.money:
                print("{} yuan coin number={}".format(mp[0], mp[1]))


s = None
for cmd in input().split(";"):
    if not cmd.strip():
        continue
    
    if cmd in ("q0", "q1"):
        print("E010:Parameter error")
        continue
        
    c, *args = cmd.split()
    if c == "r":
        s = shop(list(map(int, args[0].split("-"))), list(map(int, args[1].split("-"))))
    elif c == "p":
        s.put(int(args[0]))
    elif c == "b":
        s.buy(args[0])
    elif c == "c":
        s.withdraw()
    elif c == "q":
        s.query(args[0])
</pre>
<hr/>
<h1>HJ99 自守数</h1>
<p><span class="desc">描述</span><br/>自守数是指一个数的平方的尾数等于该数自身的自然数。例如：25^2 = 625，76^2 = 5776，9376^2 = 87909376。请求出n(包括n)以内的自守数的个数<br/><br/>数据范围：<br/>1≤n≤10000 <br/><br/><br/>输入描述：<br/>int型整数<br/>输出描述：<br/>n以内自守数的数量。<br/><span class="example">示例1</span><br/>输入：<br/>6<br/>输出：<br/>4<br/>说明：<br/>有0，1，5，6这四个自守数      <br/><span class="example">示例2</span><br/>输入：<br/>1<br/>输出：<br/>2<br/>说明：<br/>有0, 1这两个自守数</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())

cnt = 0
for i in range(0, n+1):
    if str(i * i).endswith(str(i)):
        cnt += 1
print(cnt)
</pre>
<hr/>
<h1>HJ100 等差数列</h1>
<p><span class="desc">描述</span><br/>等差数列 2，5，8，11，14。。。。<br/>（从 2 开始的 3 为公差的等差数列）<br/>输出求等差数列前n项和<br/><br/>数据范围：<br/>1≤n≤1000 <br/>输入描述：<br/>输入一个正整数n。<br/>输出描述：<br/>输出一个相加后的整数。<br/><span class="example">示例1</span><br/>输入：<br/>2<br/>输出：<br/>7<br/>说明：<br/>2+5=7  <br/><span class="example">示例2</span><br/>输入：<br/>275<br/>输出：<br/>113575<br/>说明：<br/>2+5+...+821+824=113575</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())

print((2 + (n-1) * 3 + 2) * n // 2)
</pre>
<hr/>
<h1>HJ101 输入整型数组和排序标识，对其元素按照升序或降序进行排序</h1>
<p><span class="desc">描述</span><br/>输入整型数组和排序标识，对其元素按照升序或降序进行排序<br/><br/>数据范围：<br/>1≤n≤1000  ，元素大小满足<br/>0≤val≤100000 <br/>输入描述：<br/>第一行输入数组元素个数<br/>第二行输入待排序的数组，每个数用空格隔开<br/>第三行输入一个整数0或1。0代表升序排序，1代表降序排序<br/>输出描述：<br/>输出排好序的数字<br/><span class="example">示例1</span><br/>输入：<br/>8<br/>1 2 4 9 3 55 64 25<br/>0<br/>输出：<br/>1 2 3 4 9 25 55 64<br/><span class="example">示例2</span><br/>输入：<br/>5<br/>1 2 3 4 5<br/>1<br/>输出：<br/>5 4 3 2 1</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = input()
arr = list(map(int, input().strip().split()))
rev = input().strip() == "1"
arr.sort(reverse=rev)
print(" ".join(map(str, arr)))
</pre>
<hr/>
<h1>HJ102 字符统计</h1>
<p><span class="desc">描述</span><br/>输入一个只包含小写英文字母和数字的字符串，按照不同字符统计个数由多到少输出统计结果，如果统计的个数相同，则按照ASCII码由小到大排序输出。<br/>数据范围：字符串长度满足<br/>1 \le len(str) \le 1000 \<br/>1≤len(str)≤1000 <br/>输入描述：<br/>一个只包含小写英文字母和数字的字符串。<br/>输出描述：<br/>一个字符串，为不同字母出现次数的降序表示。若出现次数相同，则按ASCII码的升序输出。<br/><span class="example">示例1</span><br/>输入：<br/>aaddccdc<br/>输出：<br/>cda<br/>说明：<br/>样例里，c和d出现3次，a出现2次，但c的ASCII码比d小，所以先输出c，再输出d，最后输出a.</p>
<button onclick='show(event)'>显示代码</button>
<pre>
stat = {}
for c in input().strip():
    stat[c] = stat.get(c, 0) + 1
    
print(''.join(p[1] for p in sorted((-stat[c], c) for c in stat)))
</pre>
<hr/>
<h1>HJ103 Redraiment的走法</h1>
<p><span class="desc">描述</span><br/>Redraiment是走梅花桩的高手。Redraiment可以选择任意一个起点，从前到后，但只能从低处往高处的桩子走。他希望走的步数最多，你能替Redraiment研究他最多走的步数吗？<br/><br/>数据范围：每组数据长度满足<br/>1≤n≤200  ， 数据大小满足<br/>1≤val≤350 <br/><br/><br/>输入描述：<br/>数据共2行，第1行先输入数组的个数，第2行再输入梅花桩的高度<br/>输出描述：<br/>输出一个结果<br/><span class="example">示例1</span><br/>输入：<br/>6<br/>2 5 1 5 4 5 <br/>输出：<br/>3<br/>说明：<br/>6个点的高度各为 2 5 1 5 4 5<br/>如从第1格开始走,最多为3步, 2 4 5 ，下标分别是 1 5 6<br/>从第2格开始走,最多只有1步,5<br/>而从第3格开始走最多有3步,1 4 5， 下标分别是 3 5 6<br/>从第5格开始走最多有2步,4 5， 下标分别是 5 6<br/>所以这个结果是3。</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = int(input())
nums = list(map(int, input().split()))

dp = [1] * n
for i in range(n):
    for j in range(i):
        if nums[i] > nums[j]:
            dp[i] = max(dp[j]+1, dp[i])
print(max(dp))
</pre>
<hr/>
<h1>HJ105 记负均正II</h1>
<p><span class="desc">描述</span><br/>输入 n 个整型数，统计其中的负数个数并求所有非负数的平均值，结果保留一位小数，如果没有非负数，则平均值为0<br/>本题有多组输入数据，输入到文件末尾。<br/><br/>数据范围：<br/>1≤n≤50000  ，其中每个数都满足<br/>|val| \le 10^{6} \<br/>∣val∣≤10<br/>6<br/> <br/>输入描述：<br/>输入任意个整数，每行输入一个。<br/>输出描述：<br/>输出负数个数以及所有非负数的平均值<br/><span class="example">示例1</span><br/>输入：<br/>-13<br/>-4<br/>-7<br/>输出：<br/>3<br/>0.0<br/><span class="example">示例2</span><br/>输入：<br/>-12<br/>1<br/>2<br/>输出：<br/>1<br/>1.5</p>
<button onclick='show(event)'>显示代码</button>
<pre>
import sys


nc = 0
pc = 0
ps = 0.0

for sn in sys.stdin:
    n = float(sn)
    if n < 0:
        nc += 1
    else:
        ps += n
        pc += 1

print("{}\n{:0.1f}".format(nc, 0.0 if pc == 0 else ps / pc))
</pre>
<hr/>
<h1>HJ106 字符逆序</h1>
<p><span class="desc">描述</span><br/>将一个字符串str的内容颠倒过来，并输出。<br/><br/>数据范围：<br/>1 \le len(str) \le 10000\<br/>1≤len(str)≤10000 <br/>输入描述：<br/>输入一个字符串，可以有空格<br/>输出描述：<br/>输出逆序的字符串<br/><span class="example">示例1</span><br/>输入：<br/>I am a student<br/>输出：<br/>tneduts a ma I<br/><span class="example">示例2</span><br/>输入：<br/>nowcoder<br/>输出：<br/>redocwon</p>
<button onclick='show(event)'>显示代码</button>
<pre>
print(input().strip()[::-1])
</pre>
<hr/>
<h1>HJ107 求解立方根</h1>
<p><span class="desc">描述</span><br/>计算一个浮点数的立方根，不使用库函数。<br/>保留一位小数。<br/><br/>数据范围：<br/>∣val∣≤20 <br/>输入描述：<br/>待求解参数，为double类型（一个实数）<br/>输出描述：<br/>输出参数的立方根。保留一位小数。<br/><span class="example">示例1</span><br/>输入：<br/>19.9<br/>输出：<br/>2.7<br/><span class="example">示例2</span><br/>输入：<br/>2.7<br/>输出：<br/>1.4</p>
<button onclick='show(event)'>显示代码</button>
<pre>
n = float(input())

if n > 0:
    print("{:.1f}".format(n**(1/3)))
else:
    print("-{:.1f}".format((-n)**(1/3)))
</pre>
<hr/>
<h1>HJ108 求最小公倍数</h1>
<p><span class="desc">描述</span><br/>正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。<br/><br/>数据范围：<br/>1≤a,b≤100000 <br/>输入描述：<br/>输入两个正整数A和B。<br/>输出描述：<br/>输出A和B的最小公倍数。<br/><span class="example">示例1</span><br/>输入：<br/>5 7<br/>输出：<br/>35<br/><span class="example">示例2</span><br/>输入：<br/>2 4<br/>输出：<br/>4</p>
<button onclick='show(event)'>显示代码</button>
<pre>
def gcd(a, b):
    while b > 0:
        a, b = b, a % b
    return a

a, b = list(map(int, input().strip().split()))
print(a * b // gcd(a, b))
</pre>
<hr/>

